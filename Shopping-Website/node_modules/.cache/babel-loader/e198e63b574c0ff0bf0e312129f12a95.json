{"ast":null,"code":"// Utils\nimport { defineComponent as _defineComponent, // eslint-disable-line no-restricted-imports\ncomputed, getCurrentInstance, shallowRef, watchEffect } from 'vue';\nimport { consoleWarn } from \"./console.mjs\";\nimport { mergeDeep, pick, toKebabCase } from \"./helpers.mjs\";\nimport { injectSelf } from \"./injectSelf.mjs\";\nimport { propsFactory } from \"./propsFactory.mjs\";\nimport { DefaultsSymbol, provideDefaults, useDefaults } from \"../composables/defaults.mjs\";\nimport { useToggleScope } from \"../composables/toggleScope.mjs\"; // Types\n\nfunction propIsDefined(vnode, prop) {\n  return typeof vnode.props?.[prop] !== 'undefined' || typeof vnode.props?.[toKebabCase(prop)] !== 'undefined';\n} // No props\n// Implementation\n\n\nexport function defineComponent(options) {\n  options._setup = options._setup ?? options.setup;\n\n  if (!options.name) {\n    consoleWarn('The component is missing an explicit name, unable to generate default prop value');\n    return options;\n  }\n\n  if (options._setup) {\n    options.props = propsFactory(options.props ?? {}, toKebabCase(options.name))();\n    const propKeys = Object.keys(options.props);\n\n    options.filterProps = function filterProps(props) {\n      return pick(props, propKeys);\n    };\n\n    options.props._as = String;\n\n    options.setup = function setup(props, ctx) {\n      const defaults = useDefaults(); // Skip props proxy if defaults are not provided\n\n      if (!defaults.value) return options._setup(props, ctx);\n      const vm = getCurrentInstance();\n      const componentDefaults = computed(() => defaults.value[props._as ?? options.name]);\n\n      const _props = new Proxy(props, {\n        get(target, prop) {\n          const propValue = Reflect.get(target, prop);\n\n          if (typeof prop === 'string' && !propIsDefined(vm.vnode, prop)) {\n            return componentDefaults.value?.[prop] ?? defaults.value.global?.[prop] ?? propValue;\n          }\n\n          return propValue;\n        }\n\n      });\n\n      const _subcomponentDefaults = shallowRef();\n\n      watchEffect(() => {\n        if (componentDefaults.value) {\n          const subComponents = Object.entries(componentDefaults.value).filter(_ref => {\n            let [key] = _ref;\n            return key.startsWith(key[0].toUpperCase());\n          });\n          if (subComponents.length) _subcomponentDefaults.value = Object.fromEntries(subComponents);\n        }\n      });\n\n      const setupBindings = options._setup(_props, ctx); // If subcomponent defaults are provided, override any\n      // subcomponents provided by the component's setup function.\n      // This uses injectSelf so must be done after the original setup to work.\n\n\n      useToggleScope(_subcomponentDefaults, () => {\n        provideDefaults(mergeDeep(injectSelf(DefaultsSymbol)?.value ?? {}, _subcomponentDefaults.value));\n      });\n      return setupBindings;\n    };\n  }\n\n  return options;\n} // Implementation\n\nexport function genericComponent() {\n  let exposeDefaults = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n  return options => (exposeDefaults ? defineComponent : _defineComponent)(options);\n}\nexport function defineFunctionalComponent(props, render) {\n  render.props = props;\n  return render;\n}","map":{"version":3,"mappings":"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","names":["defineComponent","_defineComponent","computed","getCurrentInstance","shallowRef","watchEffect","consoleWarn","mergeDeep","pick","toKebabCase","injectSelf","propsFactory","DefaultsSymbol","provideDefaults","useDefaults","useToggleScope","propIsDefined","vnode","prop","props","options","_setup","setup","name","propKeys","Object","keys","filterProps","_as","String","ctx","defaults","value","vm","componentDefaults","_props","Proxy","get","target","propValue","Reflect","global","_subcomponentDefaults","subComponents","entries","filter","_ref","key","startsWith","toUpperCase","length","fromEntries","setupBindings","genericComponent","exposeDefaults","defineFunctionalComponent","render"],"sources":["../../src/util/defineComponent.tsx"],"sourcesContent":["// Utils\nimport {\n  defineComponent as _defineComponent, // eslint-disable-line no-restricted-imports\n  computed,\n  getCurrentInstance,\n  shallowRef,\n  watchEffect,\n} from 'vue'\nimport { consoleWarn } from '@/util/console'\nimport { mergeDeep, pick, toKebabCase } from '@/util/helpers'\nimport { injectSelf } from '@/util/injectSelf'\nimport { propsFactory } from '@/util/propsFactory'\nimport { DefaultsSymbol, provideDefaults, useDefaults } from '@/composables/defaults'\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Types\nimport type {\n  AllowedComponentProps,\n  ComponentCustomProps,\n  ComponentObjectPropsOptions,\n  ComponentOptions,\n  ComponentOptionsMixin,\n  ComponentOptionsWithObjectProps,\n  ComponentOptionsWithoutProps,\n  ComponentPropsOptions,\n  ComputedOptions,\n  DefineComponent,\n  EmitsOptions,\n  ExtractDefaultPropTypes,\n  ExtractPropTypes,\n  FunctionalComponent,\n  MethodOptions,\n  ObjectEmitsOptions,\n  VNode,\n  VNodeChild,\n  VNodeProps,\n} from 'vue'\n\nfunction propIsDefined (vnode: VNode, prop: string) {\n  return typeof vnode.props?.[prop] !== 'undefined' ||\n    typeof vnode.props?.[toKebabCase(prop)] !== 'undefined'\n}\n\n// No props\nexport function defineComponent<\n  Props = {},\n  RawBindings = {},\n  D = {},\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = {},\n  EE extends string = string,\n  I extends {} = {},\n  II extends string = string\n>(\n  options: ComponentOptionsWithoutProps<\n    Props,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE,\n    I,\n    II\n  >\n): DefineComponent<Props, RawBindings, D, C, M, Mixin, Extends, E, EE>\n\n// Object Props\nexport function defineComponent<\n  PropsOptions extends Readonly<ComponentPropsOptions>,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = {},\n  EE extends string = string,\n  I extends {} = {},\n  II extends string = string\n>(\n  options: ComponentOptionsWithObjectProps<\n    PropsOptions,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E,\n    EE,\n    I,\n    II\n  >\n): DefineComponent<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE> & FilterPropsOptions<PropsOptions>\n\n// Implementation\nexport function defineComponent (options: ComponentOptions) {\n  options._setup = options._setup ?? options.setup\n\n  if (!options.name) {\n    consoleWarn('The component is missing an explicit name, unable to generate default prop value')\n\n    return options\n  }\n\n  if (options._setup) {\n    options.props = propsFactory(options.props ?? {}, toKebabCase(options.name))()\n    const propKeys = Object.keys(options.props)\n    options.filterProps = function filterProps (props: Record<string, any>) {\n      return pick(props, propKeys)\n    }\n\n    options.props._as = String\n    options.setup = function setup (props: Record<string, any>, ctx) {\n      const defaults = useDefaults()\n\n      // Skip props proxy if defaults are not provided\n      if (!defaults.value) return options._setup(props, ctx)\n\n      const vm = getCurrentInstance()!\n      const componentDefaults = computed(() => defaults.value![props._as ?? options.name!])\n      const _props = new Proxy(props, {\n        get (target, prop) {\n          const propValue = Reflect.get(target, prop)\n          if (typeof prop === 'string' && !propIsDefined(vm.vnode, prop)) {\n            return componentDefaults.value?.[prop] ?? defaults.value!.global?.[prop] ?? propValue\n          }\n          return propValue\n        },\n      })\n\n      const _subcomponentDefaults = shallowRef()\n      watchEffect(() => {\n        if (componentDefaults.value) {\n          const subComponents = Object.entries(componentDefaults.value).filter(([key]) => key.startsWith(key[0].toUpperCase()))\n          if (subComponents.length) _subcomponentDefaults.value = Object.fromEntries(subComponents)\n        }\n      })\n\n      const setupBindings = options._setup(_props, ctx)\n\n      // If subcomponent defaults are provided, override any\n      // subcomponents provided by the component's setup function.\n      // This uses injectSelf so must be done after the original setup to work.\n      useToggleScope(_subcomponentDefaults, () => {\n        provideDefaults(mergeDeep(\n          injectSelf(DefaultsSymbol)?.value ?? {},\n          _subcomponentDefaults.value\n        ))\n      })\n\n      return setupBindings\n    }\n  }\n\n  return options\n}\n\ntype ToListeners<T extends string | number | symbol> = { [K in T]: K extends `on${infer U}` ? Uncapitalize<U> : K }[T]\n\nexport type SlotsToProps<T extends Record<string, any>> = T extends Record<string, Slot> ? ({\n  $children?: (\n    | VNodeChild\n    | (keyof T extends 'default' ? T['default'] : {})\n    | { [K in keyof T]?: T[K] }\n  )\n  $slots?: { [K in keyof T]?: T[K] }\n  'v-slots'?: { [K in keyof T]?: T[K] | false }\n} & {\n  [K in keyof T as `v-slot:${K & string}`]?: T[K] | false\n}) : T extends Record<string, any[]> ? SlotsToProps<MakeSlots<T>> : never\n\ntype Slot<T extends any[] = any[]> = (...args: T) => VNodeChild\nexport type MakeSlots<T extends Record<string, any[]>> = {\n  [K in keyof T]: Slot<T[K]>\n}\n\nexport type GenericSlot = SlotsToProps<{ default: [] }>\n\ntype DefineComponentWithGenericProps<T extends (new () => {\n  $props?: Record<string, any>\n})> = <\n  PropsOptions extends Readonly<ComponentPropsOptions>,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = Record<string, any>,\n  EE extends string = string,\n  I = InstanceType<T>,\n  Base = DefineComponent<\n    I extends Record<'$props', any>\n      ? Omit<PropsOptions, keyof I['$props']>\n      : PropsOptions,\n    RawBindings,\n    D,\n    C,\n    M,\n    Mixin,\n    Extends,\n    E extends any[] ? E : I extends Record<'$props', any> ? Omit<E, ToListeners<keyof I['$props']>> : E,\n    EE\n  >\n>(\n  options: ComponentOptionsWithObjectProps<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE>\n) => Base & T & FilterPropsOptions<PropsOptions>\n\ntype DefineComponentWithSlots<Slots extends Record<string, any[]> | Record<string, Slot>> = <\n  PropsOptions extends Readonly<ComponentPropsOptions>,\n  RawBindings,\n  D,\n  C extends ComputedOptions = {},\n  M extends MethodOptions = {},\n  Mixin extends ComponentOptionsMixin = ComponentOptionsMixin,\n  Extends extends ComponentOptionsMixin = ComponentOptionsMixin,\n  E extends EmitsOptions = Record<string, any>,\n  EE extends string = string,\n>(\n  options: ComponentOptionsWithObjectProps<PropsOptions, RawBindings, D, C, M, Mixin, Extends, E, EE>\n) => DefineComponent<\n  ExtractPropTypes<PropsOptions> & SlotsToProps<Slots>,\n  RawBindings,\n  D,\n  C,\n  M,\n  Mixin,\n  Extends,\n  E,\n  EE,\n  PublicProps,\n  ExtractPropTypes<PropsOptions> & SlotsToProps<Slots> & ({} extends E ? {} : EmitsToProps<E>),\n  ExtractDefaultPropTypes<PropsOptions>\n> & FilterPropsOptions<PropsOptions>\n\n// No argument - simple default slot\nexport function genericComponent (exposeDefaults?: boolean): DefineComponentWithSlots<{ default: [] }>\n\n// Generic constructor argument - generic props and slots\nexport function genericComponent<T extends (new () => {\n  $props?: Record<string, any>\n})> (exposeDefaults?: boolean): DefineComponentWithGenericProps<T>\n\n// Slots argument - simple slots\nexport function genericComponent<\n  Slots extends Record<string, any[]> | Record<string, Slot>\n> (exposeDefaults?: boolean): DefineComponentWithSlots<Slots>\n\n// Implementation\nexport function genericComponent (exposeDefaults = true) {\n  return (options: any) => ((exposeDefaults ? defineComponent : _defineComponent) as any)(options)\n}\n\nexport function defineFunctionalComponent<\n  T extends FunctionalComponent<Props>,\n  PropsOptions = ComponentObjectPropsOptions,\n  Defaults = ExtractDefaultPropTypes<PropsOptions>,\n  Props = Readonly<ExtractPropTypes<PropsOptions>>,\n> (props: PropsOptions, render: T): FunctionalComponent<Partial<Defaults> & Omit<Props, keyof Defaults>> {\n  render.props = props as any\n  return render as any\n}\n\ntype EmitsToProps<T extends EmitsOptions> = T extends string[]\n  ? {\n    [K in string & `on${Capitalize<T[number]>}`]?: (...args: any[]) => any\n  }\n  : T extends ObjectEmitsOptions\n    ? {\n      [K in string &\n        `on${Capitalize<string & keyof T>}`]?: K extends `on${infer C}`\n        ? T[Uncapitalize<C>] extends null\n          ? (...args: any[]) => any\n          : (\n            ...args: T[Uncapitalize<C>] extends (...args: infer P) => any\n              ? P\n              : never\n          ) => any\n        : never\n    }\n    : {}\n\ntype PublicProps =\n  & VNodeProps\n  & AllowedComponentProps\n  & ComponentCustomProps\n\n// Adds a filterProps method to the component options\nexport interface FilterPropsOptions<PropsOptions extends Readonly<ComponentPropsOptions>, Props = ExtractPropTypes<PropsOptions>> {\n  filterProps<\n    T extends Partial<Props>,\n    U extends Exclude<keyof Props, Exclude<keyof Props, keyof T>>\n  > (props: T): [yes: Partial<Pick<T, U>>, no: Omit<T, U>]\n}\n"]},"metadata":{},"sourceType":"module"}