{"ast":null,"code":"// Composables\nimport { useForm } from \"./form.mjs\";\nimport { useProxiedModel } from \"./proxiedModel.mjs\";\nimport { useToggleScope } from \"./toggleScope.mjs\";\nimport { makeFocusProps } from \"./focus.mjs\"; // Utilities\n\nimport { computed, onBeforeMount, onBeforeUnmount, onMounted, ref, unref, watch } from 'vue';\nimport { getCurrentInstanceName, getUid, propsFactory, wrapInArray } from \"../util/index.mjs\"; // Types\n\nexport const makeValidationProps = propsFactory({\n  disabled: Boolean,\n  error: Boolean,\n  errorMessages: {\n    type: [Array, String],\n    default: () => []\n  },\n  maxErrors: {\n    type: [Number, String],\n    default: 1\n  },\n  name: String,\n  label: String,\n  readonly: Boolean,\n  rules: {\n    type: Array,\n    default: () => []\n  },\n  modelValue: null,\n  validateOn: String,\n  validationValue: null,\n  ...makeFocusProps()\n}, 'validation');\nexport function useValidation(props) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getCurrentInstanceName();\n  let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getUid();\n  const model = useProxiedModel(props, 'modelValue');\n  const validationModel = computed(() => props.validationValue === undefined ? model.value : props.validationValue);\n  const form = useForm();\n  const internalErrorMessages = ref([]);\n  const isPristine = ref(true);\n  const isDirty = computed(() => !!(wrapInArray(model.value === '' ? null : model.value).length || wrapInArray(validationModel.value === '' ? null : validationModel.value).length));\n  const isDisabled = computed(() => !!(props.disabled || form?.isDisabled.value));\n  const isReadonly = computed(() => !!(props.readonly || form?.isReadonly.value));\n  const errorMessages = computed(() => {\n    return props.errorMessages.length ? wrapInArray(props.errorMessages).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;\n  });\n  const isValid = computed(() => {\n    if (props.error || errorMessages.value.length) return false;\n    if (!props.rules.length) return true;\n    return isPristine.value ? null : true;\n  });\n  const isValidating = ref(false);\n  const validationClasses = computed(() => {\n    return {\n      [`${name}--error`]: isValid.value === false,\n      [`${name}--dirty`]: isDirty.value,\n      [`${name}--disabled`]: isDisabled.value,\n      [`${name}--readonly`]: isReadonly.value\n    };\n  });\n  const uid = computed(() => props.name ?? unref(id));\n  onBeforeMount(() => {\n    form?.register({\n      id: uid.value,\n      validate,\n      reset,\n      resetValidation\n    });\n  });\n  onBeforeUnmount(() => {\n    form?.unregister(uid.value);\n  });\n  const validateOn = computed(() => props.validateOn || form?.validateOn.value || 'input'); // Set initial valid state, for inputs that might not have rules\n\n  onMounted(() => form?.update(uid.value, isValid.value, errorMessages.value));\n  useToggleScope(() => validateOn.value === 'input', () => {\n    watch(validationModel, () => {\n      if (validationModel.value != null) {\n        validate();\n      } else if (props.focused) {\n        const unwatch = watch(() => props.focused, val => {\n          if (!val) validate();\n          unwatch();\n        });\n      }\n    });\n  });\n  useToggleScope(() => validateOn.value === 'blur', () => {\n    watch(() => props.focused, val => {\n      if (!val) validate();\n    });\n  });\n  watch(isValid, () => {\n    form?.update(uid.value, isValid.value, errorMessages.value);\n  });\n\n  function reset() {\n    resetValidation();\n    model.value = null;\n  }\n\n  function resetValidation() {\n    isPristine.value = true;\n    internalErrorMessages.value = [];\n  }\n\n  async function validate() {\n    const results = [];\n    isValidating.value = true;\n\n    for (const rule of props.rules) {\n      if (results.length >= +(props.maxErrors ?? 1)) {\n        break;\n      }\n\n      const handler = typeof rule === 'function' ? rule : () => rule;\n      const result = await handler(validationModel.value);\n      if (result === true) continue;\n\n      if (typeof result !== 'string') {\n        // eslint-disable-next-line no-console\n        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);\n        continue;\n      }\n\n      results.push(result);\n    }\n\n    internalErrorMessages.value = results;\n    isValidating.value = false;\n    isPristine.value = false;\n    return internalErrorMessages.value;\n  }\n\n  return {\n    errorMessages,\n    isDirty,\n    isDisabled,\n    isReadonly,\n    isPristine,\n    isValid,\n    isValidating,\n    reset,\n    resetValidation,\n    validate,\n    validationClasses\n  };\n}","map":{"version":3,"mappings":"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","names":["useForm","useProxiedModel","useToggleScope","makeFocusProps","computed","onBeforeMount","onBeforeUnmount","onMounted","ref","unref","watch","getCurrentInstanceName","getUid","propsFactory","wrapInArray","makeValidationProps","disabled","Boolean","error","errorMessages","type","Array","String","default","maxErrors","Number","name","label","readonly","rules","modelValue","validateOn","validationValue","useValidation","props","id","model","validationModel","undefined","value","form","internalErrorMessages","isPristine","isDirty","length","isDisabled","isReadonly","slice","Math","max","isValid","isValidating","validationClasses","uid","register","validate","reset","resetValidation","unregister","update","focused","unwatch","val","results","rule","handler","result","console","warn","push"],"sources":["../../src/composables/validation.ts"],"sourcesContent":["// Composables\nimport { useForm } from '@/composables/form'\nimport { useProxiedModel } from '@/composables/proxiedModel'\nimport { useToggleScope } from '@/composables/toggleScope'\nimport { makeFocusProps } from '@/composables/focus'\n\n// Utilities\nimport { computed, onBeforeMount, onBeforeUnmount, onMounted, ref, unref, watch } from 'vue'\nimport { getCurrentInstanceName, getUid, propsFactory, wrapInArray } from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\nimport type { MaybeRef } from '@/util'\n\nexport type ValidationResult = string | boolean\nexport type ValidationRule =\n  | ValidationResult\n  | PromiseLike<ValidationResult>\n  | ((value: any) => ValidationResult)\n  | ((value: any) => PromiseLike<ValidationResult>)\n\nexport interface ValidationProps {\n  disabled: boolean\n  error: boolean\n  errorMessages: string | string[]\n  focused: boolean\n  maxErrors: string | number\n  name: string | undefined\n  label: string | undefined\n  readonly: boolean\n  rules: ValidationRule[]\n  modelValue: any\n  'onUpdate:modelValue': ((val: any) => void) | undefined\n  validateOn?: 'blur' | 'input' | 'submit'\n  validationValue: any\n}\n\nexport const makeValidationProps = propsFactory({\n  disabled: Boolean,\n  error: Boolean,\n  errorMessages: {\n    type: [Array, String] as PropType<string | string[]>,\n    default: () => ([]),\n  },\n  maxErrors: {\n    type: [Number, String],\n    default: 1,\n  },\n  name: String,\n  label: String,\n  readonly: Boolean,\n  rules: {\n    type: Array as PropType<ValidationRule[]>,\n    default: () => ([]),\n  },\n  modelValue: null,\n  validateOn: String as PropType<ValidationProps['validateOn']>,\n  validationValue: null,\n\n  ...makeFocusProps(),\n}, 'validation')\n\nexport function useValidation (\n  props: ValidationProps,\n  name = getCurrentInstanceName(),\n  id: MaybeRef<string | number> = getUid(),\n) {\n  const model = useProxiedModel(props, 'modelValue')\n  const validationModel = computed(() => props.validationValue === undefined ? model.value : props.validationValue)\n  const form = useForm()\n  const internalErrorMessages = ref<string[]>([])\n  const isPristine = ref(true)\n  const isDirty = computed(() => !!(\n    wrapInArray(model.value === '' ? null : model.value).length ||\n    wrapInArray(validationModel.value === '' ? null : validationModel.value).length\n  ))\n  const isDisabled = computed(() => !!(props.disabled || form?.isDisabled.value))\n  const isReadonly = computed(() => !!(props.readonly || form?.isReadonly.value))\n  const errorMessages = computed(() => {\n    return props.errorMessages.length\n      ? wrapInArray(props.errorMessages).slice(0, Math.max(0, +props.maxErrors))\n      : internalErrorMessages.value\n  })\n  const isValid = computed(() => {\n    if (props.error || errorMessages.value.length) return false\n    if (!props.rules.length) return true\n\n    return isPristine.value ? null : true\n  })\n  const isValidating = ref(false)\n  const validationClasses = computed(() => {\n    return {\n      [`${name}--error`]: isValid.value === false,\n      [`${name}--dirty`]: isDirty.value,\n      [`${name}--disabled`]: isDisabled.value,\n      [`${name}--readonly`]: isReadonly.value,\n    }\n  })\n\n  const uid = computed(() => props.name ?? unref(id))\n\n  onBeforeMount(() => {\n    form?.register({\n      id: uid.value,\n      validate,\n      reset,\n      resetValidation,\n    })\n  })\n\n  onBeforeUnmount(() => {\n    form?.unregister(uid.value)\n  })\n\n  const validateOn = computed(() => props.validateOn || form?.validateOn.value || 'input')\n\n  // Set initial valid state, for inputs that might not have rules\n  onMounted(() => form?.update(uid.value, isValid.value, errorMessages.value))\n\n  useToggleScope(() => validateOn.value === 'input', () => {\n    watch(validationModel, () => {\n      if (validationModel.value != null) {\n        validate()\n      } else if (props.focused) {\n        const unwatch = watch(() => props.focused, val => {\n          if (!val) validate()\n\n          unwatch()\n        })\n      }\n    })\n  })\n\n  useToggleScope(() => validateOn.value === 'blur', () => {\n    watch(() => props.focused, val => {\n      if (!val) validate()\n    })\n  })\n\n  watch(isValid, () => {\n    form?.update(uid.value, isValid.value, errorMessages.value)\n  })\n\n  function reset () {\n    resetValidation()\n    model.value = null\n  }\n\n  function resetValidation () {\n    isPristine.value = true\n    internalErrorMessages.value = []\n  }\n\n  async function validate () {\n    const results = []\n\n    isValidating.value = true\n\n    for (const rule of props.rules) {\n      if (results.length >= +(props.maxErrors ?? 1)) {\n        break\n      }\n\n      const handler = typeof rule === 'function' ? rule : () => rule\n      const result = await handler(validationModel.value)\n\n      if (result === true) continue\n\n      if (typeof result !== 'string') {\n        // eslint-disable-next-line no-console\n        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`)\n\n        continue\n      }\n\n      results.push(result)\n    }\n\n    internalErrorMessages.value = results\n    isValidating.value = false\n    isPristine.value = false\n\n    return internalErrorMessages.value\n  }\n\n  return {\n    errorMessages,\n    isDirty,\n    isDisabled,\n    isReadonly,\n    isPristine,\n    isValid,\n    isValidating,\n    reset,\n    resetValidation,\n    validate,\n    validationClasses,\n  }\n}\n"]},"metadata":{},"sourceType":"module"}