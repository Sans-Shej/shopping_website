{"ast":null,"code":"import { createVNode as _createVNode } from \"vue\"; // Styles\n\nimport \"./VColorPickerCanvas.css\"; // Composables\n\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\"; // Utilities\n\nimport { clamp, convertToUnit, defineComponent, getEventCoordinates, useRender } from \"../../util/index.mjs\";\nimport { computed, onMounted, ref, watch } from 'vue'; // Types\n\nexport const VColorPickerCanvas = defineComponent({\n  name: 'VColorPickerCanvas',\n  props: {\n    color: {\n      type: Object\n    },\n    disabled: Boolean,\n    dotSize: {\n      type: [Number, String],\n      default: 10\n    },\n    height: {\n      type: [Number, String],\n      default: 150\n    },\n    width: {\n      type: [Number, String],\n      default: 300\n    }\n  },\n  emits: {\n    'update:color': color => true,\n    'update:position': hue => true\n  },\n\n  setup(props, _ref) {\n    let {\n      emit\n    } = _ref;\n    const isInteracting = ref(false);\n    const isOutsideUpdate = ref(false);\n    const dotPosition = ref({\n      x: 0,\n      y: 0\n    });\n    const dotStyles = computed(() => {\n      const {\n        x,\n        y\n      } = dotPosition.value;\n      const radius = parseInt(props.dotSize, 10) / 2;\n      return {\n        width: convertToUnit(props.dotSize),\n        height: convertToUnit(props.dotSize),\n        transform: `translate(${convertToUnit(x - radius)}, ${convertToUnit(y - radius)})`\n      };\n    });\n    const canvasRef = ref();\n    const canvasWidth = ref(parseFloat(props.width));\n    const canvasHeight = ref(parseFloat(props.height));\n    const {\n      resizeRef\n    } = useResizeObserver(entries => {\n      if (!resizeRef.value?.offsetParent) return;\n      const {\n        width,\n        height\n      } = entries[0].contentRect;\n      canvasWidth.value = width;\n      canvasHeight.value = height;\n    });\n\n    function updateDotPosition(x, y, rect) {\n      const {\n        left,\n        top,\n        width,\n        height\n      } = rect;\n      dotPosition.value = {\n        x: clamp(x - left, 0, width),\n        y: clamp(y - top, 0, height)\n      };\n    }\n\n    function handleClick(e) {\n      if (props.disabled || !canvasRef.value) return;\n      updateDotPosition(e.clientX, e.clientY, canvasRef.value.getBoundingClientRect());\n    }\n\n    function handleMouseDown(e) {\n      // To prevent selection while moving cursor\n      e.preventDefault();\n      if (props.disabled) return;\n      isInteracting.value = true;\n      window.addEventListener('mousemove', handleMouseMove);\n      window.addEventListener('mouseup', handleMouseUp);\n      window.addEventListener('touchmove', handleMouseMove);\n      window.addEventListener('touchend', handleMouseUp);\n    }\n\n    function handleMouseMove(e) {\n      if (props.disabled || !canvasRef.value) return;\n      isInteracting.value = true;\n      const coords = getEventCoordinates(e);\n      updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect());\n    }\n\n    function handleMouseUp() {\n      window.removeEventListener('mousemove', handleMouseMove);\n      window.removeEventListener('mouseup', handleMouseUp);\n      window.removeEventListener('touchmove', handleMouseMove);\n      window.removeEventListener('touchend', handleMouseUp);\n    }\n\n    watch(dotPosition, () => {\n      if (isOutsideUpdate.value) {\n        isOutsideUpdate.value = false;\n        return;\n      }\n\n      if (!canvasRef.value) return;\n      const {\n        x,\n        y\n      } = dotPosition.value;\n      emit('update:color', {\n        h: props.color?.h ?? 0,\n        s: clamp(x, 0, canvasWidth.value) / canvasWidth.value,\n        v: 1 - clamp(y, 0, canvasHeight.value) / canvasHeight.value,\n        a: props.color?.a ?? 1\n      });\n    });\n\n    function updateCanvas() {\n      if (!canvasRef.value) return;\n      const canvas = canvasRef.value;\n      const ctx = canvas.getContext('2d');\n      if (!ctx) return;\n      const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0);\n      saturationGradient.addColorStop(0, 'hsla(0, 0%, 100%, 1)'); // white\n\n      saturationGradient.addColorStop(1, `hsla(${props.color?.h ?? 0}, 100%, 50%, 1)`);\n      ctx.fillStyle = saturationGradient;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n      const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n      valueGradient.addColorStop(0, 'hsla(0, 0%, 100%, 0)'); // transparent\n\n      valueGradient.addColorStop(1, 'hsla(0, 0%, 0%, 1)'); // black\n\n      ctx.fillStyle = valueGradient;\n      ctx.fillRect(0, 0, canvas.width, canvas.height);\n    }\n\n    watch(() => props.color?.h, updateCanvas, {\n      immediate: true\n    });\n    watch(() => [canvasWidth.value, canvasHeight.value], (newVal, oldVal) => {\n      updateCanvas();\n      dotPosition.value = {\n        x: dotPosition.value.x * newVal[0] / oldVal[0],\n        y: dotPosition.value.y * newVal[1] / oldVal[1]\n      };\n    }, {\n      flush: 'post'\n    });\n    watch(() => props.color, () => {\n      if (isInteracting.value) {\n        isInteracting.value = false;\n        return;\n      }\n\n      isOutsideUpdate.value = true;\n      dotPosition.value = props.color ? {\n        x: props.color.s * canvasWidth.value,\n        y: (1 - props.color.v) * canvasHeight.value\n      } : {\n        x: 0,\n        y: 0\n      };\n    }, {\n      deep: true,\n      immediate: true\n    });\n    onMounted(() => updateCanvas());\n    useRender(() => _createVNode(\"div\", {\n      \"ref\": resizeRef,\n      \"class\": \"v-color-picker-canvas\",\n      \"onClick\": handleClick,\n      \"onMousedown\": handleMouseDown,\n      \"onTouchstart\": handleMouseDown\n    }, [_createVNode(\"canvas\", {\n      \"ref\": canvasRef,\n      \"width\": canvasWidth.value,\n      \"height\": canvasHeight.value\n    }, null), props.color && _createVNode(\"div\", {\n      \"class\": ['v-color-picker-canvas__dot', {\n        'v-color-picker-canvas__dot--disabled': props.disabled\n      }],\n      \"style\": dotStyles.value\n    }, null)]));\n    return {};\n  }\n\n});","map":{"version":3,"mappings":"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","names":["useResizeObserver","clamp","convertToUnit","defineComponent","getEventCoordinates","useRender","computed","onMounted","ref","watch","VColorPickerCanvas","name","props","color","type","Object","disabled","Boolean","dotSize","Number","String","default","height","width","emits","hue","setup","_ref","emit","isInteracting","isOutsideUpdate","dotPosition","x","y","dotStyles","value","radius","parseInt","transform","canvasRef","canvasWidth","parseFloat","canvasHeight","resizeRef","entries","offsetParent","contentRect","updateDotPosition","rect","left","top","handleClick","e","clientX","clientY","getBoundingClientRect","handleMouseDown","preventDefault","window","addEventListener","handleMouseMove","handleMouseUp","coords","removeEventListener","h","s","v","a","updateCanvas","canvas","ctx","getContext","saturationGradient","createLinearGradient","addColorStop","fillStyle","fillRect","valueGradient","immediate","newVal","oldVal","flush","deep","_createVNode"],"sources":["../../../src/components/VColorPicker/VColorPickerCanvas.tsx"],"sourcesContent":["// Styles\nimport './VColorPickerCanvas.sass'\n\n// Composables\nimport { useResizeObserver } from '@/composables/resizeObserver'\n\n// Utilities\nimport { clamp, convertToUnit, defineComponent, getEventCoordinates, useRender } from '@/util'\nimport { computed, onMounted, ref, watch } from 'vue'\n\n// Types\nimport type { HSV } from '@/util'\nimport type { PropType } from 'vue'\n\nexport const VColorPickerCanvas = defineComponent({\n  name: 'VColorPickerCanvas',\n\n  props: {\n    color: {\n      type: Object as PropType<HSV | null>,\n    },\n    disabled: Boolean,\n    dotSize: {\n      type: [Number, String],\n      default: 10,\n    },\n    height: {\n      type: [Number, String],\n      default: 150,\n    },\n    width: {\n      type: [Number, String],\n      default: 300,\n    },\n  },\n\n  emits: {\n    'update:color': (color: HSV) => true,\n    'update:position': (hue: any) => true,\n  },\n\n  setup (props, { emit }) {\n    const isInteracting = ref(false)\n    const isOutsideUpdate = ref(false)\n    const dotPosition = ref({ x: 0, y: 0 })\n\n    const dotStyles = computed(() => {\n      const { x, y } = dotPosition.value\n      const radius = parseInt(props.dotSize, 10) / 2\n\n      return {\n        width: convertToUnit(props.dotSize),\n        height: convertToUnit(props.dotSize),\n        transform: `translate(${convertToUnit(x - radius)}, ${convertToUnit(y - radius)})`,\n      }\n    })\n\n    const canvasRef = ref<HTMLCanvasElement | null>()\n    const canvasWidth = ref(parseFloat(props.width))\n    const canvasHeight = ref(parseFloat(props.height))\n    const { resizeRef } = useResizeObserver(entries => {\n      if (!resizeRef.value?.offsetParent) return\n\n      const { width, height } = entries[0].contentRect\n\n      canvasWidth.value = width\n      canvasHeight.value = height\n    })\n\n    function updateDotPosition (x: number, y: number, rect: DOMRect) {\n      const { left, top, width, height } = rect\n      dotPosition.value = {\n        x: clamp(x - left, 0, width),\n        y: clamp(y - top, 0, height),\n      }\n    }\n\n    function handleClick (e: MouseEvent) {\n      if (props.disabled || !canvasRef.value) return\n\n      updateDotPosition(e.clientX, e.clientY, canvasRef.value.getBoundingClientRect())\n    }\n\n    function handleMouseDown (e: MouseEvent | TouchEvent) {\n      // To prevent selection while moving cursor\n      e.preventDefault()\n\n      if (props.disabled) return\n\n      isInteracting.value = true\n\n      window.addEventListener('mousemove', handleMouseMove)\n      window.addEventListener('mouseup', handleMouseUp)\n      window.addEventListener('touchmove', handleMouseMove)\n      window.addEventListener('touchend', handleMouseUp)\n    }\n\n    function handleMouseMove (e: MouseEvent | TouchEvent) {\n      if (props.disabled || !canvasRef.value) return\n\n      isInteracting.value = true\n\n      const coords = getEventCoordinates(e)\n\n      updateDotPosition(coords.clientX, coords.clientY, canvasRef.value.getBoundingClientRect())\n    }\n\n    function handleMouseUp () {\n      window.removeEventListener('mousemove', handleMouseMove)\n      window.removeEventListener('mouseup', handleMouseUp)\n      window.removeEventListener('touchmove', handleMouseMove)\n      window.removeEventListener('touchend', handleMouseUp)\n    }\n\n    watch(dotPosition, () => {\n      if (isOutsideUpdate.value) {\n        isOutsideUpdate.value = false\n        return\n      }\n\n      if (!canvasRef.value) return\n\n      const { x, y } = dotPosition.value\n\n      emit('update:color', {\n        h: props.color?.h ?? 0,\n        s: clamp(x, 0, canvasWidth.value) / canvasWidth.value,\n        v: 1 - clamp(y, 0, canvasHeight.value) / canvasHeight.value,\n        a: props.color?.a ?? 1,\n      })\n    })\n\n    function updateCanvas () {\n      if (!canvasRef.value) return\n\n      const canvas = canvasRef.value\n      const ctx = canvas.getContext('2d')\n\n      if (!ctx) return\n\n      const saturationGradient = ctx.createLinearGradient(0, 0, canvas.width, 0)\n      saturationGradient.addColorStop(0, 'hsla(0, 0%, 100%, 1)') // white\n      saturationGradient.addColorStop(1, `hsla(${props.color?.h ?? 0}, 100%, 50%, 1)`)\n      ctx.fillStyle = saturationGradient\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\n\n      const valueGradient = ctx.createLinearGradient(0, 0, 0, canvas.height)\n      valueGradient.addColorStop(0, 'hsla(0, 0%, 100%, 0)') // transparent\n      valueGradient.addColorStop(1, 'hsla(0, 0%, 0%, 1)') // black\n      ctx.fillStyle = valueGradient\n      ctx.fillRect(0, 0, canvas.width, canvas.height)\n    }\n\n    watch(() => props.color?.h, updateCanvas, { immediate: true })\n    watch(() => [canvasWidth.value, canvasHeight.value], (newVal, oldVal) => {\n      updateCanvas()\n      dotPosition.value = {\n        x: dotPosition.value.x * newVal[0] / oldVal[0],\n        y: dotPosition.value.y * newVal[1] / oldVal[1],\n      }\n    }, { flush: 'post' })\n\n    watch(() => props.color, () => {\n      if (isInteracting.value) {\n        isInteracting.value = false\n        return\n      }\n\n      isOutsideUpdate.value = true\n\n      dotPosition.value = props.color ? {\n        x: props.color.s * canvasWidth.value,\n        y: (1 - props.color.v) * canvasHeight.value,\n      } : { x: 0, y: 0 }\n    }, { deep: true, immediate: true })\n\n    onMounted(() => updateCanvas())\n\n    useRender(() => (\n      <div\n        ref={ resizeRef }\n        class=\"v-color-picker-canvas\"\n        onClick={ handleClick }\n        onMousedown={ handleMouseDown }\n        onTouchstart={ handleMouseDown }\n      >\n        <canvas\n          ref={ canvasRef }\n          width={ canvasWidth.value }\n          height={ canvasHeight.value }\n        />\n        { props.color && (\n          <div\n            class={[\n              'v-color-picker-canvas__dot',\n              {\n                'v-color-picker-canvas__dot--disabled': props.disabled,\n              },\n            ]}\n            style={ dotStyles.value }\n          />\n        )}\n      </div>\n    ))\n\n    return {}\n  },\n})\n\nexport type VColorPickerCanvas = InstanceType<typeof VColorPickerCanvas>\n"]},"metadata":{},"sourceType":"module"}