{"ast":null,"code":"// Utilities\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue';\nimport { clamp, consoleError, convertToUnit, destructComputed, flipAlign, flipCorner, flipSide, getAxis, getScrollParents, IN_BROWSER, isFixedPosition, nullifyTransforms, parseAnchor, propsFactory } from \"../../util/index.mjs\";\nimport { Box, getOverflow } from \"../../util/box.mjs\";\nimport { anchorToPoint, getOffset } from \"./util/point.mjs\"; // Composables\n\nimport { useToggleScope } from \"../../composables/toggleScope.mjs\"; // Types\n\nconst locationStrategies = {\n  static: staticLocationStrategy,\n  // specific viewport position, usually centered\n  connected: connectedLocationStrategy // connected to a certain element\n\n};\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function],\n    default: 'static',\n    validator: val => typeof val === 'function' || val in locationStrategies\n  },\n  location: {\n    type: String,\n    default: 'bottom'\n  },\n  origin: {\n    type: String,\n    default: 'auto'\n  },\n  offset: [Number, String, Array]\n}, 'v-overlay-location-strategies');\nexport function useLocationStrategies(props, data) {\n  const contentStyles = ref({});\n  const updateLocation = ref();\n\n  if (IN_BROWSER) {\n    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), reset => {\n      watch(() => props.locationStrategy, reset);\n      onScopeDispose(() => {\n        updateLocation.value = undefined;\n      });\n\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation;\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation;\n      }\n    });\n    window.addEventListener('resize', onResize, {\n      passive: true\n    });\n    onScopeDispose(() => {\n      window.removeEventListener('resize', onResize);\n      updateLocation.value = undefined;\n    });\n  }\n\n  function onResize(e) {\n    updateLocation.value?.(e);\n  }\n\n  return {\n    contentStyles,\n    updateLocation\n  };\n}\n\nfunction staticLocationStrategy() {// TODO\n}\n/** Get size of element ignoring max-width/max-height */\n\n\nfunction getIntrinsicSize(el, isRtl) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el);\n\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0);\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0);\n  }\n\n  contentBox.y -= parseFloat(el.style.top || 0); // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox;\n}\n\nfunction connectedLocationStrategy(data, props, contentStyles) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value);\n\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed'\n    });\n  }\n\n  const {\n    preferredAnchor,\n    preferredOrigin\n  } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value);\n    const parsedOrigin = props.origin === 'overlap' ? parsedAnchor : props.origin === 'auto' ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value); // Some combinations of props may produce an invalid origin\n\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin)\n      };\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin\n      };\n    }\n  });\n  const [minWidth, minHeight, maxWidth, maxHeight] = ['minWidth', 'minHeight', 'maxWidth', 'maxHeight'].map(key => {\n    return computed(() => {\n      const val = parseFloat(props[key]);\n      return isNaN(val) ? Infinity : val;\n    });\n  });\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset;\n    }\n\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat);\n      if (offset.length < 2) offset.push(0);\n      return offset;\n    }\n\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0];\n  });\n  let observe = false;\n  const observer = new ResizeObserver(() => {\n    if (observe) updateLocation();\n  });\n  watch([data.activatorEl, data.contentEl], (_ref, _ref2) => {\n    let [newActivatorEl, newContentEl] = _ref;\n    let [oldActivatorEl, oldContentEl] = _ref2;\n    if (oldActivatorEl) observer.unobserve(oldActivatorEl);\n    if (newActivatorEl) observer.observe(newActivatorEl);\n    if (oldContentEl) observer.unobserve(oldContentEl);\n    if (newContentEl) observer.observe(newContentEl);\n  }, {\n    immediate: true\n  });\n  onScopeDispose(() => {\n    observer.disconnect();\n  }); // eslint-disable-next-line max-statements\n\n  function updateLocation() {\n    observe = false;\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true);\n    });\n    if (!data.activatorEl.value || !data.contentEl.value) return;\n    const targetBox = data.activatorEl.value.getBoundingClientRect();\n    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value);\n    const scrollParents = getScrollParents(data.contentEl.value);\n    const viewportMargin = 12;\n\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement);\n\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0);\n        contentBox.y += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0);\n      }\n    }\n\n    const viewport = scrollParents.reduce((box, el) => {\n      const rect = el.getBoundingClientRect();\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight\n      });\n\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)\n        });\n      }\n\n      return scrollBox;\n    }, undefined);\n    viewport.x += viewportMargin;\n    viewport.y += viewportMargin;\n    viewport.width -= viewportMargin * 2;\n    viewport.height -= viewportMargin * 2;\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value\n    };\n\n    function checkOverflow(_placement) {\n      const box = new Box(contentBox);\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox);\n      const contentPoint = anchorToPoint(_placement.origin, box);\n      let {\n        x,\n        y\n      } = getOffset(targetPoint, contentPoint);\n\n      switch (_placement.anchor.side) {\n        case 'top':\n          y -= offset.value[0];\n          break;\n\n        case 'bottom':\n          y += offset.value[0];\n          break;\n\n        case 'left':\n          x -= offset.value[0];\n          break;\n\n        case 'right':\n          x += offset.value[0];\n          break;\n      }\n\n      switch (_placement.anchor.align) {\n        case 'top':\n          y -= offset.value[1];\n          break;\n\n        case 'bottom':\n          y += offset.value[1];\n          break;\n\n        case 'left':\n          x -= offset.value[1];\n          break;\n\n        case 'right':\n          x += offset.value[1];\n          break;\n      }\n\n      box.x += x;\n      box.y += y;\n      box.width = Math.min(box.width, maxWidth.value);\n      box.height = Math.min(box.height, maxHeight.value);\n      const overflows = getOverflow(box, viewport);\n      return {\n        overflows,\n        x,\n        y\n      };\n    }\n\n    let x = 0;\n    let y = 0;\n    const available = {\n      x: 0,\n      y: 0\n    };\n    const flipped = {\n      x: false,\n      y: false\n    };\n    let resets = -1;\n\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy');\n        break;\n      }\n\n      const {\n        x: _x,\n        y: _y,\n        overflows\n      } = checkOverflow(placement);\n      x += _x;\n      y += _y;\n      contentBox.x += _x;\n      contentBox.y += _y; // flip\n\n      {\n        const axis = getAxis(placement.anchor);\n        const hasOverflowX = overflows.x.before || overflows.x.after;\n        const hasOverflowY = overflows.y.before || overflows.y.after;\n        let reset = false;\n        ['x', 'y'].forEach(key => {\n          if (key === 'x' && hasOverflowX && !flipped.x || key === 'y' && hasOverflowY && !flipped.y) {\n            const newPlacement = {\n              anchor: { ...placement.anchor\n              },\n              origin: { ...placement.origin\n              }\n            };\n            const flip = key === 'x' ? axis === 'y' ? flipAlign : flipSide : axis === 'y' ? flipSide : flipAlign;\n            newPlacement.anchor = flip(newPlacement.anchor);\n            newPlacement.origin = flip(newPlacement.origin);\n            const {\n              overflows: newOverflows\n            } = checkOverflow(newPlacement);\n\n            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {\n              placement = newPlacement;\n              reset = flipped[key] = true;\n            }\n          }\n        });\n        if (reset) continue;\n      } // shift\n\n      if (overflows.x.before) {\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n      }\n\n      if (overflows.x.after) {\n        x -= overflows.x.after;\n        contentBox.x -= overflows.x.after;\n      }\n\n      if (overflows.y.before) {\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n\n      if (overflows.y.after) {\n        y -= overflows.y.after;\n        contentBox.y -= overflows.y.after;\n      } // size\n\n\n      {\n        const overflows = getOverflow(contentBox, viewport);\n        available.x = viewport.width - overflows.x.before - overflows.x.after;\n        available.y = viewport.height - overflows.y.before - overflows.y.after;\n        x += overflows.x.before;\n        contentBox.x += overflows.x.before;\n        y += overflows.y.before;\n        contentBox.y += overflows.y.before;\n      }\n      break;\n    }\n\n    const axis = getAxis(placement.anchor);\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))\n    });\n    return {\n      available,\n      contentBox\n    };\n  }\n\n  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());\n  nextTick(() => {\n    const result = updateLocation(); // TODO: overflowing content should only require a single updateLocation call\n    // Icky hack to make sure the content is positioned consistently\n\n    if (!result) return;\n    const {\n      available,\n      contentBox\n    } = result;\n\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(() => {\n        updateLocation();\n        requestAnimationFrame(() => {\n          updateLocation();\n        });\n      });\n    }\n  });\n  return {\n    updateLocation\n  };\n}\n\nfunction pixelRound(val) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio;\n}\n\nfunction pixelCeil(val) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;\n}","map":{"version":3,"mappings":"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","names":["computed","nextTick","onScopeDispose","ref","watch","clamp","consoleError","convertToUnit","destructComputed","flipAlign","flipCorner","flipSide","getAxis","getScrollParents","IN_BROWSER","isFixedPosition","nullifyTransforms","parseAnchor","propsFactory","Box","getOverflow","anchorToPoint","getOffset","useToggleScope","locationStrategies","static","staticLocationStrategy","connected","connectedLocationStrategy","makeLocationStrategyProps","locationStrategy","type","String","Function","default","validator","val","location","origin","offset","Number","Array","useLocationStrategies","props","data","contentStyles","updateLocation","isActive","value","reset","undefined","window","addEventListener","onResize","passive","removeEventListener","e","getIntrinsicSize","el","isRtl","contentBox","x","parseFloat","style","right","left","y","top","activatorFixed","activatorEl","Object","assign","position","preferredAnchor","preferredOrigin","parsedAnchor","parsedOrigin","side","align","minWidth","minHeight","maxWidth","maxHeight","map","key","isNaN","Infinity","isArray","split","length","push","observe","observer","ResizeObserver","contentEl","newActivatorEl","newContentEl","_ref","oldActivatorEl","oldContentEl","_ref2","unobserve","immediate","disconnect","requestAnimationFrame","targetBox","getBoundingClientRect","scrollParents","viewportMargin","document","documentElement","getPropertyValue","viewport","reduce","box","rect","scrollBox","width","clientWidth","height","clientHeight","Math","max","min","bottom","placement","anchor","checkOverflow","_placement","targetPoint","contentPoint","overflows","available","flipped","resets","_x","_y","axis","hasOverflowX","before","after","hasOverflowY","forEach","newPlacement","flip","newOverflows","transformOrigin","pixelRound","pixelCeil","result","round","devicePixelRatio","ceil"],"sources":["../../../src/components/VOverlay/locationStrategies.ts"],"sourcesContent":["// Utilities\nimport { computed, nextTick, onScopeDispose, ref, watch } from 'vue'\nimport {\n  clamp,\n  consoleError,\n  convertToUnit,\n  destructComputed,\n  flipAlign,\n  flipCorner,\n  flipSide,\n  getAxis,\n  getScrollParents,\n  IN_BROWSER,\n  isFixedPosition,\n  nullifyTransforms,\n  parseAnchor,\n  propsFactory,\n} from '@/util'\nimport { Box, getOverflow } from '@/util/box'\nimport { anchorToPoint, getOffset } from './util/point'\n\n// Composables\nimport { useToggleScope } from '@/composables/toggleScope'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { Anchor } from '@/util'\n\nexport interface LocationStrategyData {\n  contentEl: Ref<HTMLElement | undefined>\n  activatorEl: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n  isRtl: Ref<boolean>\n}\n\ntype LocationStrategyFn = (\n  data: LocationStrategyData,\n  props: StrategyProps,\n  contentStyles: Ref<Record<string, string>>\n) => undefined | { updateLocation: (e: Event) => void }\n\nconst locationStrategies = {\n  static: staticLocationStrategy, // specific viewport position, usually centered\n  connected: connectedLocationStrategy, // connected to a certain element\n}\n\nexport interface StrategyProps {\n  locationStrategy: keyof typeof locationStrategies | LocationStrategyFn\n  location: Anchor\n  origin: Anchor | 'auto' | 'overlap'\n  offset?: number | string | number[]\n  maxHeight?: number | string\n  maxWidth?: number | string\n  minHeight?: number | string\n  minWidth?: number | string\n}\n\nexport const makeLocationStrategyProps = propsFactory({\n  locationStrategy: {\n    type: [String, Function] as PropType<StrategyProps['locationStrategy']>,\n    default: 'static',\n    validator: (val: any) => typeof val === 'function' || val in locationStrategies,\n  },\n  location: {\n    type: String as PropType<StrategyProps['location']>,\n    default: 'bottom',\n  },\n  origin: {\n    type: String as PropType<StrategyProps['origin']>,\n    default: 'auto',\n  },\n  offset: [Number, String, Array] as PropType<StrategyProps['offset']>,\n}, 'v-overlay-location-strategies')\n\nexport function useLocationStrategies (\n  props: StrategyProps,\n  data: LocationStrategyData\n) {\n  const contentStyles = ref({})\n  const updateLocation = ref<(e: Event) => void>()\n\n  if (IN_BROWSER) {\n    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), reset => {\n      watch(() => props.locationStrategy, reset)\n      onScopeDispose(() => {\n        updateLocation.value = undefined\n      })\n\n      if (typeof props.locationStrategy === 'function') {\n        updateLocation.value = props.locationStrategy(data, props, contentStyles)?.updateLocation\n      } else {\n        updateLocation.value = locationStrategies[props.locationStrategy](data, props, contentStyles)?.updateLocation\n      }\n    })\n\n    window.addEventListener('resize', onResize, { passive: true })\n\n    onScopeDispose(() => {\n      window.removeEventListener('resize', onResize)\n      updateLocation.value = undefined\n    })\n  }\n\n  function onResize (e: Event) {\n    updateLocation.value?.(e)\n  }\n\n  return {\n    contentStyles,\n    updateLocation,\n  }\n}\n\nfunction staticLocationStrategy () {\n  // TODO\n}\n\n/** Get size of element ignoring max-width/max-height */\nfunction getIntrinsicSize (el: HTMLElement, isRtl: boolean) {\n  // const scrollables = new Map<Element, [number, number]>()\n  // el.querySelectorAll('*').forEach(el => {\n  //   const x = el.scrollLeft\n  //   const y = el.scrollTop\n  //   if (x || y) {\n  //     scrollables.set(el, [x, y])\n  //   }\n  // })\n\n  // const initialMaxWidth = el.style.maxWidth\n  // const initialMaxHeight = el.style.maxHeight\n  // el.style.removeProperty('max-width')\n  // el.style.removeProperty('max-height')\n\n  /* eslint-disable-next-line sonarjs/prefer-immediate-return */\n  const contentBox = nullifyTransforms(el)\n\n  if (isRtl) {\n    contentBox.x += parseFloat(el.style.right || 0)\n  } else {\n    contentBox.x -= parseFloat(el.style.left || 0)\n  }\n  contentBox.y -= parseFloat(el.style.top || 0)\n\n  // el.style.maxWidth = initialMaxWidth\n  // el.style.maxHeight = initialMaxHeight\n  // scrollables.forEach((position, el) => {\n  //   el.scrollTo(...position)\n  // })\n\n  return contentBox\n}\n\nfunction connectedLocationStrategy (data: LocationStrategyData, props: StrategyProps, contentStyles: Ref<Record<string, string>>) {\n  const activatorFixed = isFixedPosition(data.activatorEl.value)\n  if (activatorFixed) {\n    Object.assign(contentStyles.value, {\n      position: 'fixed',\n    })\n  }\n\n  const { preferredAnchor, preferredOrigin } = destructComputed(() => {\n    const parsedAnchor = parseAnchor(props.location, data.isRtl.value)\n    const parsedOrigin =\n      props.origin === 'overlap' ? parsedAnchor\n      : props.origin === 'auto' ? flipSide(parsedAnchor)\n      : parseAnchor(props.origin, data.isRtl.value)\n\n    // Some combinations of props may produce an invalid origin\n    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {\n      return {\n        preferredAnchor: flipCorner(parsedAnchor),\n        preferredOrigin: flipCorner(parsedOrigin),\n      }\n    } else {\n      return {\n        preferredAnchor: parsedAnchor,\n        preferredOrigin: parsedOrigin,\n      }\n    }\n  })\n\n  const [minWidth, minHeight, maxWidth, maxHeight] =\n    (['minWidth', 'minHeight', 'maxWidth', 'maxHeight'] as const).map(key => {\n      return computed(() => {\n        const val = parseFloat(props[key]!)\n        return isNaN(val) ? Infinity : val\n      })\n    })\n\n  const offset = computed(() => {\n    if (Array.isArray(props.offset)) {\n      return props.offset\n    }\n    if (typeof props.offset === 'string') {\n      const offset = props.offset.split(' ').map(parseFloat)\n      if (offset.length < 2) offset.push(0)\n      return offset\n    }\n    return typeof props.offset === 'number' ? [props.offset, 0] : [0, 0]\n  })\n\n  let observe = false\n  const observer = new ResizeObserver(() => {\n    if (observe) updateLocation()\n  })\n\n  watch([data.activatorEl, data.contentEl], ([newActivatorEl, newContentEl], [oldActivatorEl, oldContentEl]) => {\n    if (oldActivatorEl) observer.unobserve(oldActivatorEl)\n    if (newActivatorEl) observer.observe(newActivatorEl)\n\n    if (oldContentEl) observer.unobserve(oldContentEl)\n    if (newContentEl) observer.observe(newContentEl)\n  }, {\n    immediate: true,\n  })\n\n  onScopeDispose(() => {\n    observer.disconnect()\n  })\n\n  // eslint-disable-next-line max-statements\n  function updateLocation () {\n    observe = false\n    requestAnimationFrame(() => {\n      requestAnimationFrame(() => observe = true)\n    })\n\n    if (!data.activatorEl.value || !data.contentEl.value) return\n\n    const targetBox = data.activatorEl.value.getBoundingClientRect()\n    const contentBox = getIntrinsicSize(data.contentEl.value, data.isRtl.value)\n    const scrollParents = getScrollParents(data.contentEl.value)\n    const viewportMargin = 12\n\n    if (!scrollParents.length) {\n      scrollParents.push(document.documentElement)\n      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {\n        contentBox.x += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-x') || 0)\n        contentBox.y += parseFloat(document.documentElement.style.getPropertyValue('--v-body-scroll-y') || 0)\n      }\n    }\n\n    const viewport = scrollParents.reduce<Box>((box: Box | undefined, el) => {\n      const rect = el.getBoundingClientRect()\n      const scrollBox = new Box({\n        x: el === document.documentElement ? 0 : rect.x,\n        y: el === document.documentElement ? 0 : rect.y,\n        width: el.clientWidth,\n        height: el.clientHeight,\n      })\n\n      if (box) {\n        return new Box({\n          x: Math.max(box.left, scrollBox.left),\n          y: Math.max(box.top, scrollBox.top),\n          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),\n          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top),\n        })\n      }\n      return scrollBox\n    }, undefined!)\n    viewport.x += viewportMargin\n    viewport.y += viewportMargin\n    viewport.width -= viewportMargin * 2\n    viewport.height -= viewportMargin * 2\n\n    let placement = {\n      anchor: preferredAnchor.value,\n      origin: preferredOrigin.value,\n    }\n\n    function checkOverflow (_placement: typeof placement) {\n      const box = new Box(contentBox)\n      const targetPoint = anchorToPoint(_placement.anchor, targetBox)\n      const contentPoint = anchorToPoint(_placement.origin, box)\n\n      let { x, y } = getOffset(targetPoint, contentPoint)\n\n      switch (_placement.anchor.side) {\n        case 'top': y -= offset.value[0]; break\n        case 'bottom': y += offset.value[0]; break\n        case 'left': x -= offset.value[0]; break\n        case 'right': x += offset.value[0]; break\n      }\n\n      switch (_placement.anchor.align) {\n        case 'top': y -= offset.value[1]; break\n        case 'bottom': y += offset.value[1]; break\n        case 'left': x -= offset.value[1]; break\n        case 'right': x += offset.value[1]; break\n      }\n\n      box.x += x\n      box.y += y\n\n      box.width = Math.min(box.width, maxWidth.value)\n      box.height = Math.min(box.height, maxHeight.value)\n\n      const overflows = getOverflow(box, viewport)\n\n      return { overflows, x, y }\n    }\n\n    let x = 0; let y = 0\n    const available = { x: 0, y: 0 }\n    const flipped = { x: false, y: false }\n    let resets = -1\n    while (true) {\n      if (resets++ > 10) {\n        consoleError('Infinite loop detected in connectedLocationStrategy')\n        break\n      }\n\n      const { x: _x, y: _y, overflows } = checkOverflow(placement)\n\n      x += _x\n      y += _y\n\n      contentBox.x += _x\n      contentBox.y += _y\n\n      // flip\n      {\n        const axis = getAxis(placement.anchor)\n        const hasOverflowX = overflows.x.before || overflows.x.after\n        const hasOverflowY = overflows.y.before || overflows.y.after\n\n        let reset = false\n        ;['x', 'y'].forEach(key => {\n          if (\n            (key === 'x' && hasOverflowX && !flipped.x) ||\n            (key === 'y' && hasOverflowY && !flipped.y)\n          ) {\n            const newPlacement = { anchor: { ...placement.anchor }, origin: { ...placement.origin } }\n            const flip = key === 'x'\n              ? axis === 'y' ? flipAlign : flipSide\n              : axis === 'y' ? flipSide : flipAlign\n            newPlacement.anchor = flip(newPlacement.anchor)\n            newPlacement.origin = flip(newPlacement.origin)\n            const { overflows: newOverflows } = checkOverflow(newPlacement)\n            if (\n              (newOverflows[key].before <= overflows[key].before &&\n                newOverflows[key].after <= overflows[key].after) ||\n              (newOverflows[key].before + newOverflows[key].after <\n                (overflows[key].before + overflows[key].after) / 2)\n            ) {\n              placement = newPlacement\n              reset = flipped[key] = true\n            }\n          }\n        })\n        if (reset) continue\n      }\n\n      // shift\n      if (overflows.x.before) {\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n      }\n      if (overflows.x.after) {\n        x -= overflows.x.after\n        contentBox.x -= overflows.x.after\n      }\n      if (overflows.y.before) {\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n      if (overflows.y.after) {\n        y -= overflows.y.after\n        contentBox.y -= overflows.y.after\n      }\n\n      // size\n      {\n        const overflows = getOverflow(contentBox, viewport)\n        available.x = viewport.width - overflows.x.before - overflows.x.after\n        available.y = viewport.height - overflows.y.before - overflows.y.after\n\n        x += overflows.x.before\n        contentBox.x += overflows.x.before\n        y += overflows.y.before\n        contentBox.y += overflows.y.before\n      }\n\n      break\n    }\n\n    const axis = getAxis(placement.anchor)\n\n    Object.assign(contentStyles.value, {\n      '--v-overlay-anchor-origin': `${placement.anchor.side} ${placement.anchor.align}`,\n      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,\n      // transform: `translate(${pixelRound(x)}px, ${pixelRound(y)}px)`,\n      top: convertToUnit(pixelRound(y)),\n      left: data.isRtl.value ? undefined : convertToUnit(pixelRound(x)),\n      right: data.isRtl.value ? convertToUnit(pixelRound(-x)) : undefined,\n      minWidth: convertToUnit(axis === 'y' ? Math.min(minWidth.value, targetBox.width) : minWidth.value),\n      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),\n      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value))),\n    })\n\n    return {\n      available,\n      contentBox,\n    }\n  }\n\n  watch(\n    () => [\n      preferredAnchor.value,\n      preferredOrigin.value,\n      props.offset,\n      props.minWidth,\n      props.minHeight,\n      props.maxWidth,\n      props.maxHeight,\n    ],\n    () => updateLocation(),\n  )\n\n  nextTick(() => {\n    const result = updateLocation()\n\n    // TODO: overflowing content should only require a single updateLocation call\n    // Icky hack to make sure the content is positioned consistently\n    if (!result) return\n    const { available, contentBox } = result\n    if (contentBox.height > available.y) {\n      requestAnimationFrame(() => {\n        updateLocation()\n        requestAnimationFrame(() => {\n          updateLocation()\n        })\n      })\n    }\n  })\n\n  return { updateLocation }\n}\n\nfunction pixelRound (val: number) {\n  return Math.round(val * devicePixelRatio) / devicePixelRatio\n}\n\nfunction pixelCeil (val: number) {\n  return Math.ceil(val * devicePixelRatio) / devicePixelRatio\n}\n"]},"metadata":{},"sourceType":"module"}