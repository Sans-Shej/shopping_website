{"ast":null,"code":"// Utilities\nimport { HexToHSV, HSLtoHSV, HSVtoHex, HSVtoHSL, HSVtoRGB, parseHex, RGBtoHSV } from \"../../../util/colorUtils.mjs\"; // Types\n\nfunction has(obj, key) {\n  return key.every(k => obj.hasOwnProperty(k));\n}\n\nexport function parseColor(color) {\n  if (!color) return null;\n  let hsva = null;\n\n  if (typeof color === 'string') {\n    const hex = parseHex(color);\n    hsva = HexToHSV(hex);\n  }\n\n  if (typeof color === 'object') {\n    if (has(color, ['r', 'g', 'b'])) {\n      hsva = RGBtoHSV(color);\n    } else if (has(color, ['h', 's', 'l'])) {\n      hsva = HSLtoHSV(color);\n    } else if (has(color, ['h', 's', 'v'])) {\n      hsva = color;\n    }\n  }\n\n  return hsva;\n}\n\nfunction stripAlpha(color, stripAlpha) {\n  if (stripAlpha) {\n    const {\n      a,\n      ...rest\n    } = color;\n    return rest;\n  }\n\n  return color;\n}\n\nexport function extractColor(color, input) {\n  if (input == null || typeof input === 'string') {\n    const hex = HSVtoHex(color);\n    if (color.a === 1) return hex.slice(0, 7);else return hex;\n  }\n\n  if (typeof input === 'object') {\n    let converted;\n    if (has(input, ['r', 'g', 'b'])) converted = HSVtoRGB(color);else if (has(input, ['h', 's', 'l'])) converted = HSVtoHSL(color);else if (has(input, ['h', 's', 'v'])) converted = color;\n    return stripAlpha(converted, !has(input, ['a']) && color.a === 1);\n  }\n\n  return color;\n}\nexport function hasAlpha(color) {\n  if (!color) return false;\n\n  if (typeof color === 'string') {\n    return color.length > 7;\n  }\n\n  if (typeof color === 'object') {\n    return has(color, ['a']) || has(color, ['alpha']);\n  }\n\n  return false;\n}\nexport const nullColor = {\n  h: 0,\n  s: 0,\n  v: 1,\n  a: 1\n};\nconst rgba = {\n  inputProps: {\n    type: 'number',\n    min: 0\n  },\n  inputs: [{\n    label: 'R',\n    max: 255,\n    step: 1,\n    getValue: c => Math.round(c.r),\n    getColor: (c, v) => ({ ...c,\n      r: Number(v)\n    })\n  }, {\n    label: 'G',\n    max: 255,\n    step: 1,\n    getValue: c => Math.round(c.g),\n    getColor: (c, v) => ({ ...c,\n      g: Number(v)\n    })\n  }, {\n    label: 'B',\n    max: 255,\n    step: 1,\n    getValue: c => Math.round(c.b),\n    getColor: (c, v) => ({ ...c,\n      b: Number(v)\n    })\n  }, {\n    label: 'A',\n    max: 1,\n    step: 0.01,\n    getValue: _ref => {\n      let {\n        a\n      } = _ref;\n      return a ? Math.round(a * 100) / 100 : 1;\n    },\n    getColor: (c, v) => ({ ...c,\n      a: Number(v)\n    })\n  }],\n  to: HSVtoRGB,\n  from: RGBtoHSV\n};\nconst rgb = { ...rgba,\n  inputs: rgba.inputs?.slice(0, 3)\n};\nconst hsla = {\n  inputProps: {\n    type: 'number',\n    min: 0\n  },\n  inputs: [{\n    label: 'H',\n    max: 360,\n    step: 1,\n    getValue: c => Math.round(c.h),\n    getColor: (c, v) => ({ ...c,\n      h: Number(v)\n    })\n  }, {\n    label: 'S',\n    max: 1,\n    step: 0.01,\n    getValue: c => Math.round(c.s * 100) / 100,\n    getColor: (c, v) => ({ ...c,\n      s: Number(v)\n    })\n  }, {\n    label: 'L',\n    max: 1,\n    step: 0.01,\n    getValue: c => Math.round(c.l * 100) / 100,\n    getColor: (c, v) => ({ ...c,\n      l: Number(v)\n    })\n  }, {\n    label: 'A',\n    max: 1,\n    step: 0.01,\n    getValue: _ref2 => {\n      let {\n        a\n      } = _ref2;\n      return a ? Math.round(a * 100) / 100 : 1;\n    },\n    getColor: (c, v) => ({ ...c,\n      a: Number(v)\n    })\n  }],\n  to: HSVtoHSL,\n  from: HSLtoHSV\n};\nconst hsl = { ...hsla,\n  inputs: hsla.inputs.slice(0, 3)\n};\nconst hexa = {\n  inputProps: {\n    type: 'text'\n  },\n  inputs: [{\n    label: 'HEXA',\n    getValue: c => c,\n    getColor: (c, v) => v\n  }],\n  to: HSVtoHex,\n  from: HexToHSV\n};\nconst hex = { ...hexa,\n  inputs: [{\n    label: 'HEX',\n    getValue: c => c.slice(0, 7),\n    getColor: (c, v) => v\n  }]\n};\nexport const modes = {\n  rgb,\n  rgba,\n  hsl,\n  hsla,\n  hex,\n  hexa\n};","map":{"version":3,"mappings":"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","names":["HexToHSV","HSLtoHSV","HSVtoHex","HSVtoHSL","HSVtoRGB","parseHex","RGBtoHSV","has","obj","key","every","k","hasOwnProperty","parseColor","color","hsva","hex","stripAlpha","a","rest","extractColor","input","slice","converted","hasAlpha","length","nullColor","h","s","v","rgba","inputProps","type","min","inputs","label","max","step","getValue","c","Math","round","r","getColor","Number","g","b","_ref","to","from","rgb","hsla","l","_ref2","hsl","hexa","modes"],"sources":["../../../../src/components/VColorPicker/util/index.ts"],"sourcesContent":["// Utilities\nimport {\n  HexToHSV,\n  HSLtoHSV,\n  HSVtoHex,\n  HSVtoHSL,\n  HSVtoRGB,\n  parseHex,\n  RGBtoHSV,\n} from '@/util/colorUtils'\n\n// Types\nimport type { HSL, HSV, RGB } from '@/util/colorUtils'\n\nfunction has (obj: object, key: string[]) {\n  return key.every(k => obj.hasOwnProperty(k))\n}\n\nexport function parseColor (color: any): HSV | null {\n  if (!color) return null\n\n  let hsva: HSV | null = null\n\n  if (typeof color === 'string') {\n    const hex = parseHex(color)\n\n    hsva = HexToHSV(hex)\n  }\n\n  if (typeof color === 'object') {\n    if (has(color, ['r', 'g', 'b'])) {\n      hsva = RGBtoHSV(color)\n    } else if (has(color, ['h', 's', 'l'])) {\n      hsva = HSLtoHSV(color)\n    } else if (has(color, ['h', 's', 'v'])) {\n      hsva = color\n    }\n  }\n\n  return hsva\n}\n\nfunction stripAlpha (color: any, stripAlpha: boolean) {\n  if (stripAlpha) {\n    const { a, ...rest } = color\n\n    return rest\n  }\n\n  return color\n}\n\nexport function extractColor (color: HSV, input: any) {\n  if (input == null || typeof input === 'string') {\n    const hex = HSVtoHex(color)\n\n    if (color.a === 1) return hex.slice(0, 7)\n    else return hex\n  }\n\n  if (typeof input === 'object') {\n    let converted\n\n    if (has(input, ['r', 'g', 'b'])) converted = HSVtoRGB(color)\n    else if (has(input, ['h', 's', 'l'])) converted = HSVtoHSL(color)\n    else if (has(input, ['h', 's', 'v'])) converted = color\n\n    return stripAlpha(converted, !has(input, ['a']) && color.a === 1)\n  }\n\n  return color\n}\n\nexport function hasAlpha (color: any) {\n  if (!color) return false\n\n  if (typeof color === 'string') {\n    return color.length > 7\n  }\n\n  if (typeof color === 'object') {\n    return has(color, ['a']) || has(color, ['alpha'])\n  }\n\n  return false\n}\n\nexport const nullColor = { h: 0, s: 0, v: 1, a: 1 }\n\nexport type ColorPickerMode = {\n  inputProps: Record<string, unknown>\n  inputs: {\n    [key: string]: any\n    getValue: (color: any) => number | string\n    getColor: (color: any, v: string) => any\n  }[]\n  from: (color: any) => HSV\n  to: (color: HSV) => any\n}\n\nconst rgba: ColorPickerMode = {\n  inputProps: {\n    type: 'number',\n    min: 0,\n  },\n  inputs: [\n    {\n      label: 'R',\n      max: 255,\n      step: 1,\n      getValue: (c: RGB) => Math.round(c.r),\n      getColor: (c: RGB, v: string): RGB => ({ ...c, r: Number(v) }),\n    },\n    {\n      label: 'G',\n      max: 255,\n      step: 1,\n      getValue: (c: RGB) => Math.round(c.g),\n      getColor: (c: RGB, v: string): RGB => ({ ...c, g: Number(v) }),\n    },\n    {\n      label: 'B',\n      max: 255,\n      step: 1,\n      getValue: (c: RGB) => Math.round(c.b),\n      getColor: (c: RGB, v: string): RGB => ({ ...c, b: Number(v) }),\n    },\n    {\n      label: 'A',\n      max: 1,\n      step: 0.01,\n      getValue: ({ a }: RGB) => a ? Math.round(a * 100) / 100 : 1,\n      getColor: (c: RGB, v: string): RGB => ({ ...c, a: Number(v) }),\n    },\n  ],\n  to: HSVtoRGB,\n  from: RGBtoHSV,\n}\n\nconst rgb = {\n  ...rgba,\n  inputs: rgba.inputs?.slice(0, 3),\n}\n\nconst hsla: ColorPickerMode = {\n  inputProps: {\n    type: 'number',\n    min: 0,\n  },\n  inputs: [\n    {\n      label: 'H',\n      max: 360,\n      step: 1,\n      getValue: (c: HSL) => Math.round(c.h),\n      getColor: (c: HSL, v: string): HSL => ({ ...c, h: Number(v) }),\n    },\n    {\n      label: 'S',\n      max: 1,\n      step: 0.01,\n      getValue: (c: HSL) => Math.round(c.s * 100) / 100,\n      getColor: (c: HSL, v: string): HSL => ({ ...c, s: Number(v) }),\n    },\n    {\n      label: 'L',\n      max: 1,\n      step: 0.01,\n      getValue: (c: HSL) => Math.round(c.l * 100) / 100,\n      getColor: (c: HSL, v: string): HSL => ({ ...c, l: Number(v) }),\n    },\n    {\n      label: 'A',\n      max: 1,\n      step: 0.01,\n      getValue: ({ a }: HSL) => a ? Math.round(a * 100) / 100 : 1,\n      getColor: (c: HSL, v: string): HSL => ({ ...c, a: Number(v) }),\n    },\n  ],\n  to: HSVtoHSL,\n  from: HSLtoHSV,\n}\n\nconst hsl = {\n  ...hsla,\n  inputs: hsla.inputs.slice(0, 3),\n}\n\nconst hexa: ColorPickerMode = {\n  inputProps: {\n    type: 'text',\n  },\n  inputs: [\n    {\n      label: 'HEXA',\n      getValue: (c: string) => c,\n      getColor: (c: string, v: string) => v,\n    },\n  ],\n  to: HSVtoHex,\n  from: HexToHSV,\n}\n\nconst hex = {\n  ...hexa,\n  inputs: [\n    {\n      label: 'HEX',\n      getValue: (c: string) => c.slice(0, 7),\n      getColor: (c: string, v: string) => v,\n    },\n  ],\n}\n\nexport const modes: Record<string, ColorPickerMode> = {\n  rgb,\n  rgba,\n  hsl,\n  hsla,\n  hex,\n  hexa,\n}\n"]},"metadata":{},"sourceType":"module"}