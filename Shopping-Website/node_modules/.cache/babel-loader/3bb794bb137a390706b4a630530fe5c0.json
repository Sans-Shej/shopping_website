{"ast":null,"code":"import { createVNode as _createVNode } from \"vue\"; // Styles\n\nimport \"./VSlideGroup.css\"; // Components\n\nimport { VFadeTransition } from \"../transitions/index.mjs\";\nimport { VIcon } from \"../VIcon/index.mjs\"; // Composables\n\nimport { IconValue } from \"../../composables/icons.mjs\";\nimport { makeGroupProps, useGroup } from \"../../composables/group.mjs\";\nimport { makeTagProps } from \"../../composables/tag.mjs\";\nimport { useDisplay } from \"../../composables/index.mjs\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\";\nimport { useRtl } from \"../../composables/locale.mjs\"; // Utilities\n\nimport { computed, ref, watch } from 'vue';\nimport { clamp, genericComponent, IN_BROWSER, propsFactory, useRender } from \"../../util/index.mjs\";\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from \"./helpers.mjs\"; // Types\n\nexport const VSlideGroupSymbol = Symbol.for('vuetify:v-slide-group');\nexport const makeVSlideGroupProps = propsFactory({\n  centerActive: Boolean,\n  direction: {\n    type: String,\n    default: 'horizontal'\n  },\n  symbol: {\n    type: null,\n    default: VSlideGroupSymbol\n  },\n  nextIcon: {\n    type: IconValue,\n    default: '$next'\n  },\n  prevIcon: {\n    type: IconValue,\n    default: '$prev'\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: v => typeof v === 'boolean' || ['always', 'desktop', 'mobile'].includes(v)\n  },\n  ...makeTagProps(),\n  ...makeGroupProps({\n    selectedClass: 'v-slide-group-item--active'\n  })\n}, 'v-slide-group');\nexport const VSlideGroup = genericComponent()({\n  name: 'VSlideGroup',\n  props: makeVSlideGroupProps(),\n  emits: {\n    'update:modelValue': value => true\n  },\n\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      isRtl\n    } = useRtl();\n    const {\n      mobile\n    } = useDisplay();\n    const group = useGroup(props, props.symbol);\n    const isOverflowing = ref(false);\n    const scrollOffset = ref(0);\n    const containerSize = ref(0);\n    const contentSize = ref(0);\n    const isHorizontal = computed(() => props.direction === 'horizontal');\n    const {\n      resizeRef: containerRef,\n      contentRect: containerRect\n    } = useResizeObserver();\n    const {\n      resizeRef: contentRef,\n      contentRect\n    } = useResizeObserver();\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[0]);\n    });\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1;\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1]);\n    });\n\n    if (IN_BROWSER) {\n      let frame = -1;\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame);\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height';\n            containerSize.value = containerRect.value[sizeProperty];\n            contentSize.value = contentRect.value[sizeProperty];\n            isOverflowing.value = containerSize.value + 1 < contentSize.value;\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value];\n\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0;\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value\n              });\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value\n              });\n            }\n          }\n        });\n      });\n    }\n\n    const disableTransition = ref(false);\n    let startTouch = 0;\n    let startOffset = 0;\n\n    function onTouchstart(e) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      startOffset = sign * scrollOffset.value;\n      startTouch = e.touches[0][sizeProperty];\n      disableTransition.value = true;\n    }\n\n    function onTouchmove(e) {\n      if (!isOverflowing.value) return;\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY';\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty]);\n    }\n\n    function onTouchend(e) {\n      const maxScrollOffset = contentSize.value - containerSize.value;\n\n      if (scrollOffset.value < 0 || !isOverflowing.value) {\n        scrollOffset.value = 0;\n      } else if (scrollOffset.value >= maxScrollOffset) {\n        scrollOffset.value = maxScrollOffset;\n      }\n\n      disableTransition.value = false;\n    }\n\n    function onScroll() {\n      if (!containerRef.value) return;\n      containerRef.value[isHorizontal.value ? 'scrollLeft' : 'scrollTop'] = 0;\n    }\n\n    const isFocused = ref(false);\n\n    function onFocusin(e) {\n      isFocused.value = true;\n      if (!isOverflowing.value || !contentRef.value) return; // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value\n            });\n            return;\n          }\n        }\n      }\n    }\n\n    function onFocusout(e) {\n      isFocused.value = false;\n    }\n\n    function onFocus(e) {\n      if (!isFocused.value && !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget))) focus();\n    }\n\n    function onKeydown(e) {\n      if (!contentRef.value) return;\n\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          focus(isRtl.value ? 'prev' : 'next');\n        } else if (e.key === 'ArrowLeft') {\n          focus(isRtl.value ? 'next' : 'prev');\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          focus('next');\n        } else if (e.key === 'ArrowUp') {\n          focus('prev');\n        }\n      }\n\n      if (e.key === 'Home') {\n        focus('first');\n      } else if (e.key === 'End') {\n        focus('last');\n      }\n    }\n\n    function focus(location) {\n      if (!contentRef.value) return;\n\n      if (!location) {\n        const focusable = [...contentRef.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])')].filter(el => !el.hasAttribute('disabled'));\n        focusable[0]?.focus();\n      } else if (location === 'next') {\n        const el = contentRef.value.querySelector(':focus')?.nextElementSibling;\n        if (el) el.focus();else focus('first');\n      } else if (location === 'prev') {\n        const el = contentRef.value.querySelector(':focus')?.previousElementSibling;\n        if (el) el.focus();else focus('last');\n      } else if (location === 'first') {\n        contentRef.value.firstElementChild?.focus();\n      } else if (location === 'last') {\n        contentRef.value.lastElementChild?.focus();\n      }\n    }\n\n    function scrollTo(location) {\n      const newAbsoluteOffset = scrollOffset.value + (location === 'prev' ? -1 : 1) * containerSize.value;\n      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value);\n    }\n\n    const contentStyles = computed(() => {\n      // This adds friction when scrolling the 'wrong' way when at max offset\n      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value) : -scrollOffset.value; // This adds friction when scrolling the 'wrong' way when at min offset\n\n      if (scrollOffset.value <= 0) {\n        scrollAmount = bias(-scrollOffset.value);\n      }\n\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1;\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${sign * scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : ''\n      };\n    });\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected\n    }));\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always':\n          return true;\n        // Always show arrows on desktop\n\n        case 'desktop':\n          return !mobile.value;\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n\n        case true:\n          return isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        // Always show on mobile\n\n        case 'mobile':\n          return mobile.value || isOverflowing.value || Math.abs(scrollOffset.value) > 0;\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n\n        default:\n          return !mobile.value && (isOverflowing.value || Math.abs(scrollOffset.value) > 0);\n      }\n    });\n    const hasPrev = computed(() => {\n      return Math.abs(scrollOffset.value) > 0;\n    });\n    const hasNext = computed(() => {\n      // Check one scroll ahead to know the width of right-most item\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value;\n    });\n    useRender(() => _createVNode(props.tag, {\n      \"class\": ['v-slide-group', {\n        'v-slide-group--vertical': !isHorizontal.value,\n        'v-slide-group--has-affixes': hasAffixes.value,\n        'v-slide-group--is-overflowing': isOverflowing.value\n      }],\n      \"tabindex\": isFocused.value || group.selected.value.length ? -1 : 0,\n      \"onFocus\": onFocus\n    }, {\n      default: () => [hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"prev\",\n        \"class\": ['v-slide-group__prev', {\n          'v-slide-group__prev--disabled': !hasPrev.value\n        }],\n        \"onClick\": () => scrollTo('prev')\n      }, [slots.prev?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.nextIcon : props.prevIcon\n        }, null)]\n      })]), _createVNode(\"div\", {\n        \"key\": \"container\",\n        \"ref\": containerRef,\n        \"class\": \"v-slide-group__container\",\n        \"onScroll\": onScroll\n      }, [_createVNode(\"div\", {\n        \"ref\": contentRef,\n        \"class\": \"v-slide-group__content\",\n        \"style\": contentStyles.value,\n        \"onTouchstartPassive\": onTouchstart,\n        \"onTouchmovePassive\": onTouchmove,\n        \"onTouchendPassive\": onTouchend,\n        \"onFocusin\": onFocusin,\n        \"onFocusout\": onFocusout,\n        \"onKeydown\": onKeydown\n      }, [slots.default?.(slotProps.value)])]), hasAffixes.value && _createVNode(\"div\", {\n        \"key\": \"next\",\n        \"class\": ['v-slide-group__next', {\n          'v-slide-group__next--disabled': !hasNext.value\n        }],\n        \"onClick\": () => scrollTo('next')\n      }, [slots.next?.(slotProps.value) ?? _createVNode(VFadeTransition, null, {\n        default: () => [_createVNode(VIcon, {\n          \"icon\": isRtl.value ? props.prevIcon : props.nextIcon\n        }, null)]\n      })])]\n    }));\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus\n    };\n  }\n\n});","map":{"version":3,"mappings":"mDAAA;;AACA,2B,CAEA;;AAAA,SACSA,eADT,QACwB,0BADxB;AACwB,SACfC,KADe,QACV,oBADU,C,CAGxB;;AAAA,SACSC,SADT,QACkB,6BADlB;AACkB,SACTC,cADS,EACOC,QADP,QACe,6BADf;AACe,SACxBC,YADwB,QACZ,2BADY;AACZ,SACZC,UADY,QACF,6BADE;AACF,SACVC,iBADU,QACO,sCADP;AACO,SACjBC,MADiB,QACX,8BADW,C,CAG1B;;AACA,SAASC,QAAT,EAAmBC,GAAnB,EAAwBC,KAAxB,QAAqC,KAArC;AAA0C,SACjCC,KADiC,EAC1BC,gBAD0B,EACRC,UADQ,EACIC,YADJ,EACkBC,SADlB,QAC2B,sBAD3B;AAC2B,SAC5DC,IAD4D,EACtDC,uBADsD,EAC7BC,sBAD6B,QACP,eADO,C,CAGrE;;AAIA,OAAO,MAAMC,iBAA6C,GAAGC,MAAM,CAACC,GAAPD,CAAW,uBAAXA,CAAtD;AAeP,OAAO,MAAME,oBAAoB,GAAGR,YAAY,CAAC;EAC/CS,YAAY,EAAEC,OADiC;EAE/CC,SAAS,EAAE;IACTC,IAAI,EAAEC,MADG;IAETC,OAAO,EAAE;EAFA,CAFoC;EAM/CC,MAAM,EAAE;IACNH,IAAI,EAAE,IADA;IAENE,OAAO,EAAET;EAFH,CANuC;EAU/CW,QAAQ,EAAE;IACRJ,IAAI,EAAEzB,SADE;IAER2B,OAAO,EAAE;EAFD,CAVqC;EAc/CG,QAAQ,EAAE;IACRL,IAAI,EAAEzB,SADE;IAER2B,OAAO,EAAE;EAFD,CAdqC;EAkB/CI,UAAU,EAAE;IACVN,IAAI,EAAE,CAACF,OAAD,EAAUG,MAAV,CADI;IAEVM,SAAS,EAAGC,CAAM,IAChB,OAAOA,CAAP,KAAa,SAAb,IAA0B,CACxB,QADwB,EAExB,SAFwB,EAGxB,QAHwB,EAIxBC,QAJwB,CAIfD,CAJe;EAHlB,CAlBmC;EA6B/C,GAAG9B,YAAY,EA7BgC;EA8B/C,GAAGF,cAAc,CAAC;IAChBkC,aAAa,EAAE;EADC,CAAD;AA9B8B,CAAD,EAiC7C,eAjC6C,CAAzC;AAmCP,OAAO,MAAMC,WAAW,GAAGzB,gBAAgB,GAAqB;EAC9D0B,IAAI,EAAE,aADwD;EAG9DC,KAAK,EAAEjB,oBAAoB,EAHmC;EAK9DkB,KAAK,EAAE;IACL,qBAAsBC,KAAU,IAAK;EADhC,CALuD;;EAS9DC,KAAKA,CAAEH,KAAFG,EAAOC,IAAPD,EAAoB;IAAA,IAAX;MAAEE;IAAF,IAASD,IAAE;IACvB,MAAM;MAAEE;IAAF,IAAYtC,MAAM,EAAxB;IACA,MAAM;MAAEuC;IAAF,IAAazC,UAAU,EAA7B;IACA,MAAM0C,KAAK,GAAG5C,QAAQ,CAACoC,KAAD,EAAQA,KAAK,CAACV,MAAd,CAAtB;IACA,MAAMmB,aAAa,GAAGvC,GAAG,CAAC,KAAD,CAAzB;IACA,MAAMwC,YAAY,GAAGxC,GAAG,CAAC,CAAD,CAAxB;IACA,MAAMyC,aAAa,GAAGzC,GAAG,CAAC,CAAD,CAAzB;IACA,MAAM0C,WAAW,GAAG1C,GAAG,CAAC,CAAD,CAAvB;IACA,MAAM2C,YAAY,GAAG5C,QAAQ,CAAC,MAAM+B,KAAK,CAACd,SAANc,KAAoB,YAA3B,CAA7B;IAEA,MAAM;MAAEc,SAAS,EAAEC,YAAb;MAA2BC,WAAW,EAAEC;IAAxC,IAA0DlD,iBAAiB,EAAjF;IACA,MAAM;MAAE+C,SAAS,EAAEI,UAAb;MAAyBF;IAAzB,IAAyCjD,iBAAiB,EAAhE;IAEA,MAAMoD,kBAAkB,GAAGlD,QAAQ,CAAC,MAAM;MACxC,IAAI,CAACuC,KAAK,CAACY,QAANZ,CAAeN,KAAfM,CAAqBa,MAA1B,EAAkC,OAAO,CAAC,CAAR;MAElC,OAAOb,KAAK,CAACc,KAANd,CAAYN,KAAZM,CAAkBe,SAAlBf,CAA4BgB,IAAI,IAAIA,IAAI,CAACC,EAALD,KAAYhB,KAAK,CAACY,QAANZ,CAAeN,KAAfM,CAAqB,CAArBA,CAAhDA,CAAP;IACD,CAJkC,CAAnC;IAMA,MAAMkB,iBAAiB,GAAGzD,QAAQ,CAAC,MAAM;MACvC,IAAI,CAACuC,KAAK,CAACY,QAANZ,CAAeN,KAAfM,CAAqBa,MAA1B,EAAkC,OAAO,CAAC,CAAR;MAElC,OAAOb,KAAK,CAACc,KAANd,CAAYN,KAAZM,CAAkBe,SAAlBf,CAA4BgB,IAAI,IAAIA,IAAI,CAACC,EAALD,KAAYhB,KAAK,CAACY,QAANZ,CAAeN,KAAfM,CAAqBA,KAAK,CAACY,QAANZ,CAAeN,KAAfM,CAAqBa,MAArBb,GAA8B,CAAnDA,CAAhDA,CAAP;IACD,CAJiC,CAAlC;;IAMA,IAAIlC,UAAJ,EAAgB;MACd,IAAIqD,KAAK,GAAG,CAAC,CAAb;MACAxD,KAAK,CAAC,MAAM,CAACqC,KAAK,CAACY,QAANZ,CAAeN,KAAhB,EAAuBe,aAAa,CAACf,KAArC,EAA4Cc,WAAW,CAACd,KAAxD,EAA+DW,YAAY,CAACX,KAA5E,CAAP,EAA2F,MAAM;QACpG0B,oBAAoB,CAACD,KAAD,CAApBC;QACAD,KAAK,GAAGE,qBAAqB,CAAC,MAAM;UAClC,IAAIZ,aAAa,CAACf,KAAde,IAAuBD,WAAW,CAACd,KAAvC,EAA8C;YAC5C,MAAM4B,YAAY,GAAGjB,YAAY,CAACX,KAAbW,GAAqB,OAArBA,GAA+B,QAApD;YAEAF,aAAa,CAACT,KAAdS,GAAsBM,aAAa,CAACf,KAAde,CAAoBa,YAApBb,CAAtBN;YACAC,WAAW,CAACV,KAAZU,GAAoBI,WAAW,CAACd,KAAZc,CAAkBc,YAAlBd,CAApBJ;YAEAH,aAAa,CAACP,KAAdO,GAAsBE,aAAa,CAACT,KAAdS,GAAsB,CAAtBA,GAA0BC,WAAW,CAACV,KAA5DO;UACF;;UAEA,IAAIU,kBAAkB,CAACjB,KAAnBiB,IAA4B,CAA5BA,IAAiCD,UAAU,CAAChB,KAAhD,EAAuD;YACrD;YACA,MAAM6B,eAAe,GAAGb,UAAU,CAAChB,KAAXgB,CAAiBc,QAAjBd,CAA0BQ,iBAAiB,CAACxB,KAA5CgB,CAAxB;;YAEA,IAAIC,kBAAkB,CAACjB,KAAnBiB,KAA6B,CAA7BA,IAAkC,CAACV,aAAa,CAACP,KAArD,EAA4D;cAC1DQ,YAAY,CAACR,KAAbQ,GAAqB,CAArBA;YACD,CAFD,MAEO,IAAIV,KAAK,CAAChB,YAAV,EAAwB;cAC7B0B,YAAY,CAACR,KAAbQ,GAAqBhC,uBAAuB,CAAC;gBAC3CqD,eAD2C;gBAE3CpB,aAAa,EAAEA,aAAa,CAACT,KAFc;gBAG3CU,WAAW,EAAEA,WAAW,CAACV,KAHkB;gBAI3CI,KAAK,EAAEA,KAAK,CAACJ,KAJ8B;gBAK3CW,YAAY,EAAEA,YAAY,CAACX;cALgB,CAAD,CAA5CQ;YAOD,CARM,MAQA,IAAID,aAAa,CAACP,KAAlB,EAAyB;cAC9BQ,YAAY,CAACR,KAAbQ,GAAqB/B,sBAAsB,CAAC;gBAC1CoD,eAD0C;gBAE1CpB,aAAa,EAAEA,aAAa,CAACT,KAFa;gBAG1CU,WAAW,EAAEA,WAAW,CAACV,KAHiB;gBAI1CI,KAAK,EAAEA,KAAK,CAACJ,KAJ6B;gBAK1C+B,mBAAmB,EAAEvB,YAAY,CAACR,KALQ;gBAM1CW,YAAY,EAAEA,YAAY,CAACX;cANe,CAAD,CAA3CQ;YAQF;UACF;QACD,CAnC4B,CAA7BiB;MAoCD,CAtCI,CAALxD;IAuCF;;IAEA,MAAM+D,iBAAiB,GAAGhE,GAAG,CAAC,KAAD,CAA7B;IAEA,IAAIiE,UAAU,GAAG,CAAjB;IACA,IAAIC,WAAW,GAAG,CAAlB;;IAEA,SAASC,YAAT,CAAuBC,CAAvB,EAAsC;MACpC,MAAMR,YAAY,GAAGjB,YAAY,CAACX,KAAbW,GAAqB,SAArBA,GAAiC,SAAtD;MACA,MAAM0B,IAAI,GAAGjC,KAAK,CAACJ,KAANI,IAAeO,YAAY,CAACX,KAA5BI,GAAoC,CAAC,CAArCA,GAAyC,CAAtD;MACA8B,WAAW,GAAGG,IAAI,GAAG7B,YAAY,CAACR,KAAlCkC;MACAD,UAAU,GAAGG,CAAC,CAACE,OAAFF,CAAU,CAAVA,EAAaR,YAAbQ,CAAbH;MACAD,iBAAiB,CAAChC,KAAlBgC,GAA0B,IAA1BA;IACF;;IAEA,SAASO,WAAT,CAAsBH,CAAtB,EAAqC;MACnC,IAAI,CAAC7B,aAAa,CAACP,KAAnB,EAA0B;MAE1B,MAAM4B,YAAY,GAAGjB,YAAY,CAACX,KAAbW,GAAqB,SAArBA,GAAiC,SAAtD;MACA,MAAM0B,IAAI,GAAGjC,KAAK,CAACJ,KAANI,IAAeO,YAAY,CAACX,KAA5BI,GAAoC,CAAC,CAArCA,GAAyC,CAAtD;MACAI,YAAY,CAACR,KAAbQ,GAAqB6B,IAAI,IAAIH,WAAW,GAAGD,UAAdC,GAA2BE,CAAC,CAACE,OAAFF,CAAU,CAAVA,EAAaR,YAAbQ,CAA/B,CAAzB5B;IACF;;IAEA,SAASgC,UAAT,CAAqBJ,CAArB,EAAoC;MAClC,MAAMK,eAAe,GAAG/B,WAAW,CAACV,KAAZU,GAAoBD,aAAa,CAACT,KAA1D;;MAEA,IAAIQ,YAAY,CAACR,KAAbQ,GAAqB,CAArBA,IAA0B,CAACD,aAAa,CAACP,KAA7C,EAAoD;QAClDQ,YAAY,CAACR,KAAbQ,GAAqB,CAArBA;MACD,CAFD,MAEO,IAAIA,YAAY,CAACR,KAAbQ,IAAsBiC,eAA1B,EAA2C;QAChDjC,YAAY,CAACR,KAAbQ,GAAqBiC,eAArBjC;MACF;;MAEAwB,iBAAiB,CAAChC,KAAlBgC,GAA0B,KAA1BA;IACF;;IAEA,SAASU,QAAT,GAAqB;MACnB,IAAI,CAAC7B,YAAY,CAACb,KAAlB,EAAyB;MAEzBa,YAAY,CAACb,KAAba,CAAmBF,YAAY,CAACX,KAAbW,GAAqB,YAArBA,GAAoC,WAAvDE,IAAsE,CAAtEA;IACF;;IAEA,MAAM8B,SAAS,GAAG3E,GAAG,CAAC,KAAD,CAArB;;IACA,SAAS4E,SAAT,CAAoBR,CAApB,EAAmC;MACjCO,SAAS,CAAC3C,KAAV2C,GAAkB,IAAlBA;MAEA,IAAI,CAACpC,aAAa,CAACP,KAAf,IAAwB,CAACgB,UAAU,CAAChB,KAAxC,EAA+C,OAHd,CAKjC;MACA;;MACA,KAAK,MAAM6C,EAAX,IAAiBT,CAAC,CAACU,YAAFV,EAAjB,EAAmC;QACjC,KAAK,MAAMd,IAAX,IAAmBN,UAAU,CAAChB,KAAXgB,CAAiBc,QAApC,EAA8C;UAC5C,IAAIR,IAAI,KAAKuB,EAAb,EAAiB;YACfrC,YAAY,CAACR,KAAbQ,GAAqB/B,sBAAsB,CAAC;cAC1CoD,eAAe,EAAEP,IADyB;cAE1Cb,aAAa,EAAEA,aAAa,CAACT,KAFa;cAG1CU,WAAW,EAAEA,WAAW,CAACV,KAHiB;cAI1CI,KAAK,EAAEA,KAAK,CAACJ,KAJ6B;cAK1C+B,mBAAmB,EAAEvB,YAAY,CAACR,KALQ;cAM1CW,YAAY,EAAEA,YAAY,CAACX;YANe,CAAD,CAA3CQ;YAQA;UACF;QACF;MACF;IACF;;IAEA,SAASuC,UAAT,CAAqBX,CAArB,EAAoC;MAClCO,SAAS,CAAC3C,KAAV2C,GAAkB,KAAlBA;IACF;;IAEA,SAASK,OAAT,CAAkBZ,CAAlB,EAAiC;MAC/B,IACE,CAACO,SAAS,CAAC3C,KAAX,IACA,EAAEoC,CAAC,CAACa,aAAFb,IAAmBpB,UAAU,CAAChB,KAAXgB,EAAkBkC,QAAlBlC,CAA2BoB,CAAC,CAACa,aAA7BjC,CAArB,CAFF,EAGEmC,KAAK;IACT;;IAEA,SAASC,SAAT,CAAoBhB,CAApB,EAAsC;MACpC,IAAI,CAACpB,UAAU,CAAChB,KAAhB,EAAuB;;MAEvB,IAAIW,YAAY,CAACX,KAAjB,EAAwB;QACtB,IAAIoC,CAAC,CAACiB,GAAFjB,KAAU,YAAd,EAA4B;UAC1Be,KAAK,CAAC/C,KAAK,CAACJ,KAANI,GAAc,MAAdA,GAAuB,MAAxB,CAAL+C;QACD,CAFD,MAEO,IAAIf,CAAC,CAACiB,GAAFjB,KAAU,WAAd,EAA2B;UAChCe,KAAK,CAAC/C,KAAK,CAACJ,KAANI,GAAc,MAAdA,GAAuB,MAAxB,CAAL+C;QACF;MACD,CAND,MAMO;QACL,IAAIf,CAAC,CAACiB,GAAFjB,KAAU,WAAd,EAA2B;UACzBe,KAAK,CAAC,MAAD,CAALA;QACD,CAFD,MAEO,IAAIf,CAAC,CAACiB,GAAFjB,KAAU,SAAd,EAAyB;UAC9Be,KAAK,CAAC,MAAD,CAALA;QACF;MACF;;MAEA,IAAIf,CAAC,CAACiB,GAAFjB,KAAU,MAAd,EAAsB;QACpBe,KAAK,CAAC,OAAD,CAALA;MACD,CAFD,MAEO,IAAIf,CAAC,CAACiB,GAAFjB,KAAU,KAAd,EAAqB;QAC1Be,KAAK,CAAC,MAAD,CAALA;MACF;IACF;;IAEA,SAASA,KAAT,CAAgBG,QAAhB,EAA+D;MAC7D,IAAI,CAACtC,UAAU,CAAChB,KAAhB,EAAuB;;MAEvB,IAAI,CAACsD,QAAL,EAAe;QACb,MAAMC,SAAS,GAAG,CAAC,GAAGvC,UAAU,CAAChB,KAAXgB,CAAiBwC,gBAAjBxC,CACpB,0EADoBA,CAAJ,EAEfyC,MAFe,CAERZ,EAAE,IAAI,CAACA,EAAE,CAACa,YAAHb,CAAgB,UAAhBA,CAFC,CAAlB;QAGAU,SAAS,CAAC,CAAD,CAATA,EAAcJ,KAAdI;MACD,CALD,MAKO,IAAID,QAAQ,KAAK,MAAjB,EAAyB;QAC9B,MAAMT,EAAE,GAAG7B,UAAU,CAAChB,KAAXgB,CAAiB2C,aAAjB3C,CAA+B,QAA/BA,GAA0C4C,kBAArD;QACA,IAAIf,EAAJ,EAAQA,EAAE,CAACM,KAAHN,GAAR,KACKM,KAAK,CAAC,OAAD,CAALA;MACN,CAJM,MAIA,IAAIG,QAAQ,KAAK,MAAjB,EAAyB;QAC9B,MAAMT,EAAE,GAAG7B,UAAU,CAAChB,KAAXgB,CAAiB2C,aAAjB3C,CAA+B,QAA/BA,GAA0C6C,sBAArD;QACA,IAAIhB,EAAJ,EAAQA,EAAE,CAACM,KAAHN,GAAR,KACKM,KAAK,CAAC,MAAD,CAALA;MACN,CAJM,MAIA,IAAIG,QAAQ,KAAK,OAAjB,EAA0B;QAC9BtC,UAAU,CAAChB,KAAXgB,CAAiB8C,iBAAjB9C,EAAoDmC,KAApDnC;MACF,CAFM,MAEA,IAAIsC,QAAQ,KAAK,MAAjB,EAAyB;QAC7BtC,UAAU,CAAChB,KAAXgB,CAAiB+C,gBAAjB/C,EAAmDmC,KAAnDnC;MACH;IACF;;IAEA,SAASgD,QAAT,CAAmBV,QAAnB,EAA8C;MAC5C,MAAMW,iBAAiB,GAAGzD,YAAY,CAACR,KAAbQ,GAAqB,CAAC8C,QAAQ,KAAK,MAAbA,GAAsB,CAAC,CAAvBA,GAA2B,CAA5B,IAAiC7C,aAAa,CAACT,KAA9F;MAEAQ,YAAY,CAACR,KAAbQ,GAAqBtC,KAAK,CAAC+F,iBAAD,EAAoB,CAApB,EAAuBvD,WAAW,CAACV,KAAZU,GAAoBD,aAAa,CAACT,KAAzD,CAA1BQ;IACF;;IAEA,MAAM0D,aAAa,GAAGnG,QAAQ,CAAC,MAAM;MACnC;MACA,IAAIoG,YAAY,GAAG3D,YAAY,CAACR,KAAbQ,GAAqBE,WAAW,CAACV,KAAZU,GAAoBD,aAAa,CAACT,KAAvDQ,GACf,EAAEE,WAAW,CAACV,KAAZU,GAAoBD,aAAa,CAACT,KAApC,IAA6CzB,IAAI,CAACmC,WAAW,CAACV,KAAZU,GAAoBD,aAAa,CAACT,KAAlCU,GAA0CF,YAAY,CAACR,KAAxD,CADlCQ,GAEf,CAACA,YAAY,CAACR,KAFlB,CAFmC,CAMnC;;MACA,IAAIQ,YAAY,CAACR,KAAbQ,IAAsB,CAA1B,EAA6B;QAC3B2D,YAAY,GAAG5F,IAAI,CAAC,CAACiC,YAAY,CAACR,KAAf,CAAnBmE;MACF;;MAEA,MAAM9B,IAAI,GAAGjC,KAAK,CAACJ,KAANI,IAAeO,YAAY,CAACX,KAA5BI,GAAoC,CAAC,CAArCA,GAAyC,CAAtD;MACA,OAAO;QACLgE,SAAS,EAAG,YAAWzD,YAAY,CAACX,KAAbW,GAAqB,GAArBA,GAA2B,GAAI,IAAG0B,IAAI,GAAG8B,YAAa,KADxE;QAELE,UAAU,EAAErC,iBAAiB,CAAChC,KAAlBgC,GAA0B,MAA1BA,GAAmC,EAF1C;QAGLsC,UAAU,EAAEtC,iBAAiB,CAAChC,KAAlBgC,GAA0B,WAA1BA,GAAwC;MAH/C,CAAP;IAKD,CAjB6B,CAA9B;IAmBA,MAAMuC,SAAS,GAAGxG,QAAQ,CAAC,OAAO;MAChCyG,IAAI,EAAElE,KAAK,CAACkE,IADoB;MAEhCC,IAAI,EAAEnE,KAAK,CAACmE,IAFoB;MAGhCC,MAAM,EAAEpE,KAAK,CAACoE,MAHkB;MAIhCC,UAAU,EAAErE,KAAK,CAACqE;IAJc,CAAP,CAAD,CAA1B;IAOA,MAAMC,UAAU,GAAG7G,QAAQ,CAAC,MAAM;MAChC,QAAQ+B,KAAK,CAACP,UAAd;QACE;QACA,KAAK,QAAL;UAAe,OAAO,IAAP;QAEf;;QACA,KAAK,SAAL;UAAgB,OAAO,CAACc,MAAM,CAACL,KAAf;QAEhB;QACA;;QACA,KAAK,IAAL;UAAW,OAAOO,aAAa,CAACP,KAAdO,IAAuBsE,IAAI,CAACC,GAALD,CAASrE,YAAY,CAACR,KAAtB6E,IAA+B,CAA7D;QAEX;;QACA,KAAK,QAAL;UAAe,OACbxE,MAAM,CAACL,KAAPK,IACCE,aAAa,CAACP,KADfK,IACwBwE,IAAI,CAACC,GAALD,CAASrE,YAAY,CAACR,KAAtB6E,IAA+B,CAF1C;QAKf;QACA;QACA;;QACA;UAAS,OACP,CAACxE,MAAM,CAACL,KAAR,KACCO,aAAa,CAACP,KAAdO,IAAuBsE,IAAI,CAACC,GAALD,CAASrE,YAAY,CAACR,KAAtB6E,IAA+B,CADvD,CADO;MApBX;IAyBD,CA1B0B,CAA3B;IA4BA,MAAME,OAAO,GAAGhH,QAAQ,CAAC,MAAM;MAC7B,OAAO8G,IAAI,CAACC,GAALD,CAASrE,YAAY,CAACR,KAAtB6E,IAA+B,CAAtC;IACD,CAFuB,CAAxB;IAIA,MAAMG,OAAO,GAAGjH,QAAQ,CAAC,MAAM;MAC7B;MACA,OAAO2C,WAAW,CAACV,KAAZU,GAAoBmE,IAAI,CAACC,GAALD,CAASrE,YAAY,CAACR,KAAtB6E,IAA+BpE,aAAa,CAACT,KAAxE;IACD,CAHuB,CAAxB;IAKA1B,SAAS,CAAC;MAAA,SAEC,CACL,eADK,EAEL;QACE,2BAA2B,CAACqC,YAAY,CAACX,KAD3C;QAEE,8BAA8B4E,UAAU,CAAC5E,KAF3C;QAGE,iCAAiCO,aAAa,CAACP;MAHjD,CAFK,CAFD;MASL,YACW2C,SAAS,CAAC3C,KAAV2C,IAAmBrC,KAAK,CAACY,QAANZ,CAAeN,KAAfM,CAAqBa,MAAxCwB,GAAkD,CAAC,CAAnDA,GAAuD,CAV7D;MAU8D,WAC1DK;IAXJ,GAWW;MAAA7D,gBAEfyF,UAAU,CAAC5E,KAAX4E,IAAgBK;QAAA,OAEV,MAFU;QAEJ,SACH,CACL,qBADK,EAEL;UAAE,iCAAiC,CAACF,OAAO,CAAC/E;QAA5C,CAFK,CAHO;QAMb,WACSkF,MAAMlB,QAAQ,CAAC,MAAD;MAPV,GAOkB,CAE9B7D,KAAK,CAACsE,IAANtE,GAAaoE,SAAS,CAACvE,KAAvBG,KAA6B8E;QAAA9F;UAAA,QAEbiB,KAAK,CAACJ,KAANI,GAAcN,KAAK,CAACT,QAApBe,GAA+BN,KAAK,CAACR;QAFxB,GAEgC,IAFhC;MAAA,EAFC,CAPlB,CAFD,EAiBhB2F;QAAA,OAGK,WAHL;QAGgB,OACTpE,YAJP;QAImB,SACZ,0BALP;QAKiC,YACrB6B;MANZ,GAMoB;QAAA,OAGX1B,UAHW;QAGD,SACV,wBAJW;QAIa,SACtBkD,aAAa,CAAClE,KALL;QAKU,uBACLmC,YANL;QAMiB,sBACbI,WAPJ;QAOe,qBACZC,UARH;QAQa,aAClBI,SATK;QASI,cACRG,UAVI;QAUM,aACXK;MAXK,GAWI,CAEnBjD,KAAK,CAAChB,OAANgB,GAAgBoE,SAAS,CAACvE,KAA1BG,CAFmB,CAXJ,EANpB,CAjBgB,EAwCfyE,UAAU,CAAC5E,KAAX4E,IAAgBK;QAAA,OAEV,MAFU;QAEJ,SACH,CACL,qBADK,EAEL;UAAE,iCAAiC,CAACD,OAAO,CAAChF;QAA5C,CAFK,CAHO;QAMb,WACSkF,MAAMlB,QAAQ,CAAC,MAAD;MAPV,GAOkB,CAE9B7D,KAAK,CAACqE,IAANrE,GAAaoE,SAAS,CAACvE,KAAvBG,KAA6B8E;QAAA9F;UAAA,QAEbiB,KAAK,CAACJ,KAANI,GAAcN,KAAK,CAACR,QAApBc,GAA+BN,KAAK,CAACT;QAFxB,GAEgC,IAFhC;MAAA,EAFC,CAPlB,CAxCD;IAAA,CAXX,CAAD,CAATf;IAsEA,OAAO;MACL4C,QAAQ,EAAEZ,KAAK,CAACY,QADX;MAEL8C,QAFK;MAGLxD,YAHK;MAIL2C;IAJK,CAAP;EAMF;;AAxV8D,CAArB,CAApC","names":["VFadeTransition","VIcon","IconValue","makeGroupProps","useGroup","makeTagProps","useDisplay","useResizeObserver","useRtl","computed","ref","watch","clamp","genericComponent","IN_BROWSER","propsFactory","useRender","bias","calculateCenteredOffset","calculateUpdatedOffset","VSlideGroupSymbol","Symbol","for","makeVSlideGroupProps","centerActive","Boolean","direction","type","String","default","symbol","nextIcon","prevIcon","showArrows","validator","v","includes","selectedClass","VSlideGroup","name","props","emits","value","setup","_ref","slots","isRtl","mobile","group","isOverflowing","scrollOffset","containerSize","contentSize","isHorizontal","resizeRef","containerRef","contentRect","containerRect","contentRef","firstSelectedIndex","selected","length","items","findIndex","item","id","lastSelectedIndex","frame","cancelAnimationFrame","requestAnimationFrame","sizeProperty","selectedElement","children","currentScrollOffset","disableTransition","startTouch","startOffset","onTouchstart","e","sign","touches","onTouchmove","onTouchend","maxScrollOffset","onScroll","isFocused","onFocusin","el","composedPath","onFocusout","onFocus","relatedTarget","contains","focus","onKeydown","key","location","focusable","querySelectorAll","filter","hasAttribute","querySelector","nextElementSibling","previousElementSibling","firstElementChild","lastElementChild","scrollTo","newAbsoluteOffset","contentStyles","scrollAmount","transform","transition","willChange","slotProps","next","prev","select","isSelected","hasAffixes","Math","abs","hasPrev","hasNext","_createVNode","onClick"],"sources":["../../../src/components/VSlideGroup/VSlideGroup.tsx"],"sourcesContent":["// Styles\nimport './VSlideGroup.sass'\n\n// Components\nimport { VFadeTransition } from '@/components/transitions'\nimport { VIcon } from '@/components/VIcon'\n\n// Composables\nimport { IconValue } from '@/composables/icons'\nimport { makeGroupProps, useGroup } from '@/composables/group'\nimport { makeTagProps } from '@/composables/tag'\nimport { useDisplay } from '@/composables'\nimport { useResizeObserver } from '@/composables/resizeObserver'\nimport { useRtl } from '@/composables/locale'\n\n// Utilities\nimport { computed, ref, watch } from 'vue'\nimport { clamp, genericComponent, IN_BROWSER, propsFactory, useRender } from '@/util'\nimport { bias, calculateCenteredOffset, calculateUpdatedOffset } from './helpers'\n\n// Types\nimport type { GroupProvide } from '@/composables/group'\nimport type { InjectionKey, PropType } from 'vue'\n\nexport const VSlideGroupSymbol: InjectionKey<GroupProvide> = Symbol.for('vuetify:v-slide-group')\n\ninterface SlideGroupSlot {\n  next: GroupProvide['next']\n  prev: GroupProvide['prev']\n  select: GroupProvide['select']\n  isSelected: GroupProvide['isSelected']\n}\n\ntype VSlideGroupSlots = {\n  default: [SlideGroupSlot]\n  prev: [SlideGroupSlot]\n  next: [SlideGroupSlot]\n}\n\nexport const makeVSlideGroupProps = propsFactory({\n  centerActive: Boolean,\n  direction: {\n    type: String as PropType<'horizontal' | 'vertical'>,\n    default: 'horizontal',\n  },\n  symbol: {\n    type: null,\n    default: VSlideGroupSymbol,\n  },\n  nextIcon: {\n    type: IconValue,\n    default: '$next',\n  },\n  prevIcon: {\n    type: IconValue,\n    default: '$prev',\n  },\n  showArrows: {\n    type: [Boolean, String],\n    validator: (v: any) => (\n      typeof v === 'boolean' || [\n        'always',\n        'desktop',\n        'mobile',\n      ].includes(v)\n    ),\n  },\n\n  ...makeTagProps(),\n  ...makeGroupProps({\n    selectedClass: 'v-slide-group-item--active',\n  }),\n}, 'v-slide-group')\n\nexport const VSlideGroup = genericComponent<VSlideGroupSlots>()({\n  name: 'VSlideGroup',\n\n  props: makeVSlideGroupProps(),\n\n  emits: {\n    'update:modelValue': (value: any) => true,\n  },\n\n  setup (props, { slots }) {\n    const { isRtl } = useRtl()\n    const { mobile } = useDisplay()\n    const group = useGroup(props, props.symbol)\n    const isOverflowing = ref(false)\n    const scrollOffset = ref(0)\n    const containerSize = ref(0)\n    const contentSize = ref(0)\n    const isHorizontal = computed(() => props.direction === 'horizontal')\n\n    const { resizeRef: containerRef, contentRect: containerRect } = useResizeObserver()\n    const { resizeRef: contentRef, contentRect } = useResizeObserver()\n\n    const firstSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[0])\n    })\n\n    const lastSelectedIndex = computed(() => {\n      if (!group.selected.value.length) return -1\n\n      return group.items.value.findIndex(item => item.id === group.selected.value[group.selected.value.length - 1])\n    })\n\n    if (IN_BROWSER) {\n      let frame = -1\n      watch(() => [group.selected.value, containerRect.value, contentRect.value, isHorizontal.value], () => {\n        cancelAnimationFrame(frame)\n        frame = requestAnimationFrame(() => {\n          if (containerRect.value && contentRect.value) {\n            const sizeProperty = isHorizontal.value ? 'width' : 'height'\n\n            containerSize.value = containerRect.value[sizeProperty]\n            contentSize.value = contentRect.value[sizeProperty]\n\n            isOverflowing.value = containerSize.value + 1 < contentSize.value\n          }\n\n          if (firstSelectedIndex.value >= 0 && contentRef.value) {\n            // TODO: Is this too naive? Should we store element references in group composable?\n            const selectedElement = contentRef.value.children[lastSelectedIndex.value] as HTMLElement\n\n            if (firstSelectedIndex.value === 0 || !isOverflowing.value) {\n              scrollOffset.value = 0\n            } else if (props.centerActive) {\n              scrollOffset.value = calculateCenteredOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                isHorizontal: isHorizontal.value,\n              })\n            } else if (isOverflowing.value) {\n              scrollOffset.value = calculateUpdatedOffset({\n                selectedElement,\n                containerSize: containerSize.value,\n                contentSize: contentSize.value,\n                isRtl: isRtl.value,\n                currentScrollOffset: scrollOffset.value,\n                isHorizontal: isHorizontal.value,\n              })\n            }\n          }\n        })\n      })\n    }\n\n    const disableTransition = ref(false)\n\n    let startTouch = 0\n    let startOffset = 0\n\n    function onTouchstart (e: TouchEvent) {\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1\n      startOffset = sign * scrollOffset.value\n      startTouch = e.touches[0][sizeProperty]\n      disableTransition.value = true\n    }\n\n    function onTouchmove (e: TouchEvent) {\n      if (!isOverflowing.value) return\n\n      const sizeProperty = isHorizontal.value ? 'clientX' : 'clientY'\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1\n      scrollOffset.value = sign * (startOffset + startTouch - e.touches[0][sizeProperty])\n    }\n\n    function onTouchend (e: TouchEvent) {\n      const maxScrollOffset = contentSize.value - containerSize.value\n\n      if (scrollOffset.value < 0 || !isOverflowing.value) {\n        scrollOffset.value = 0\n      } else if (scrollOffset.value >= maxScrollOffset) {\n        scrollOffset.value = maxScrollOffset\n      }\n\n      disableTransition.value = false\n    }\n\n    function onScroll () {\n      if (!containerRef.value) return\n\n      containerRef.value[isHorizontal.value ? 'scrollLeft' : 'scrollTop'] = 0\n    }\n\n    const isFocused = ref(false)\n    function onFocusin (e: FocusEvent) {\n      isFocused.value = true\n\n      if (!isOverflowing.value || !contentRef.value) return\n\n      // Focused element is likely to be the root of an item, so a\n      // breadth-first search will probably find it in the first iteration\n      for (const el of e.composedPath()) {\n        for (const item of contentRef.value.children) {\n          if (item === el) {\n            scrollOffset.value = calculateUpdatedOffset({\n              selectedElement: item as HTMLElement,\n              containerSize: containerSize.value,\n              contentSize: contentSize.value,\n              isRtl: isRtl.value,\n              currentScrollOffset: scrollOffset.value,\n              isHorizontal: isHorizontal.value,\n            })\n            return\n          }\n        }\n      }\n    }\n\n    function onFocusout (e: FocusEvent) {\n      isFocused.value = false\n    }\n\n    function onFocus (e: FocusEvent) {\n      if (\n        !isFocused.value &&\n        !(e.relatedTarget && contentRef.value?.contains(e.relatedTarget as Node))\n      ) focus()\n    }\n\n    function onKeydown (e: KeyboardEvent) {\n      if (!contentRef.value) return\n\n      if (isHorizontal.value) {\n        if (e.key === 'ArrowRight') {\n          focus(isRtl.value ? 'prev' : 'next')\n        } else if (e.key === 'ArrowLeft') {\n          focus(isRtl.value ? 'next' : 'prev')\n        }\n      } else {\n        if (e.key === 'ArrowDown') {\n          focus('next')\n        } else if (e.key === 'ArrowUp') {\n          focus('prev')\n        }\n      }\n\n      if (e.key === 'Home') {\n        focus('first')\n      } else if (e.key === 'End') {\n        focus('last')\n      }\n    }\n\n    function focus (location?: 'next' | 'prev' | 'first' | 'last') {\n      if (!contentRef.value) return\n\n      if (!location) {\n        const focusable = [...contentRef.value.querySelectorAll(\n          'button, [href], input, select, textarea, [tabindex]:not([tabindex=\"-1\"])'\n        )].filter(el => !el.hasAttribute('disabled')) as HTMLElement[]\n        focusable[0]?.focus()\n      } else if (location === 'next') {\n        const el = contentRef.value.querySelector(':focus')?.nextElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('first')\n      } else if (location === 'prev') {\n        const el = contentRef.value.querySelector(':focus')?.previousElementSibling as HTMLElement | undefined\n        if (el) el.focus()\n        else focus('last')\n      } else if (location === 'first') {\n        (contentRef.value.firstElementChild as HTMLElement)?.focus()\n      } else if (location === 'last') {\n        (contentRef.value.lastElementChild as HTMLElement)?.focus()\n      }\n    }\n\n    function scrollTo (location: 'prev' | 'next') {\n      const newAbsoluteOffset = scrollOffset.value + (location === 'prev' ? -1 : 1) * containerSize.value\n\n      scrollOffset.value = clamp(newAbsoluteOffset, 0, contentSize.value - containerSize.value)\n    }\n\n    const contentStyles = computed(() => {\n      // This adds friction when scrolling the 'wrong' way when at max offset\n      let scrollAmount = scrollOffset.value > contentSize.value - containerSize.value\n        ? -(contentSize.value - containerSize.value) + bias(contentSize.value - containerSize.value - scrollOffset.value)\n        : -scrollOffset.value\n\n      // This adds friction when scrolling the 'wrong' way when at min offset\n      if (scrollOffset.value <= 0) {\n        scrollAmount = bias(-scrollOffset.value)\n      }\n\n      const sign = isRtl.value && isHorizontal.value ? -1 : 1\n      return {\n        transform: `translate${isHorizontal.value ? 'X' : 'Y'}(${sign * scrollAmount}px)`,\n        transition: disableTransition.value ? 'none' : '',\n        willChange: disableTransition.value ? 'transform' : '',\n      }\n    })\n\n    const slotProps = computed(() => ({\n      next: group.next,\n      prev: group.prev,\n      select: group.select,\n      isSelected: group.isSelected,\n    }))\n\n    const hasAffixes = computed(() => {\n      switch (props.showArrows) {\n        // Always show arrows on desktop & mobile\n        case 'always': return true\n\n        // Always show arrows on desktop\n        case 'desktop': return !mobile.value\n\n        // Show arrows on mobile when overflowing.\n        // This matches the default 2.2 behavior\n        case true: return isOverflowing.value || Math.abs(scrollOffset.value) > 0\n\n        // Always show on mobile\n        case 'mobile': return (\n          mobile.value ||\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n\n        // https://material.io/components/tabs#scrollable-tabs\n        // Always show arrows when\n        // overflowed on desktop\n        default: return (\n          !mobile.value &&\n          (isOverflowing.value || Math.abs(scrollOffset.value) > 0)\n        )\n      }\n    })\n\n    const hasPrev = computed(() => {\n      return Math.abs(scrollOffset.value) > 0\n    })\n\n    const hasNext = computed(() => {\n      // Check one scroll ahead to know the width of right-most item\n      return contentSize.value > Math.abs(scrollOffset.value) + containerSize.value\n    })\n\n    useRender(() => (\n      <props.tag\n        class={[\n          'v-slide-group',\n          {\n            'v-slide-group--vertical': !isHorizontal.value,\n            'v-slide-group--has-affixes': hasAffixes.value,\n            'v-slide-group--is-overflowing': isOverflowing.value,\n          },\n        ]}\n        tabindex={ (isFocused.value || group.selected.value.length) ? -1 : 0 }\n        onFocus={ onFocus }\n      >\n        { hasAffixes.value && (\n          <div\n            key=\"prev\"\n            class={[\n              'v-slide-group__prev',\n              { 'v-slide-group__prev--disabled': !hasPrev.value },\n            ]}\n            onClick={ () => scrollTo('prev') }\n          >\n            { slots.prev?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.nextIcon : props.prevIcon }></VIcon>\n              </VFadeTransition>\n            )}\n          </div>\n        )}\n\n        <div\n          key=\"container\"\n          ref={ containerRef }\n          class=\"v-slide-group__container\"\n          onScroll={ onScroll }\n        >\n          <div\n            ref={ contentRef }\n            class=\"v-slide-group__content\"\n            style={ contentStyles.value }\n            onTouchstartPassive={ onTouchstart }\n            onTouchmovePassive={ onTouchmove }\n            onTouchendPassive={ onTouchend }\n            onFocusin={ onFocusin }\n            onFocusout={ onFocusout }\n            onKeydown={ onKeydown }\n          >\n            { slots.default?.(slotProps.value) }\n          </div>\n        </div>\n\n        { hasAffixes.value && (\n          <div\n            key=\"next\"\n            class={[\n              'v-slide-group__next',\n              { 'v-slide-group__next--disabled': !hasNext.value },\n            ]}\n            onClick={ () => scrollTo('next') }\n          >\n            { slots.next?.(slotProps.value) ?? (\n              <VFadeTransition>\n                <VIcon icon={ isRtl.value ? props.prevIcon : props.nextIcon }></VIcon>\n              </VFadeTransition>\n            )}\n          </div>\n        )}\n      </props.tag>\n    ))\n\n    return {\n      selected: group.selected,\n      scrollTo,\n      scrollOffset,\n      focus,\n    }\n  },\n})\n\nexport type VSlideGroup = InstanceType<typeof VSlideGroup>\n"]},"metadata":{},"sourceType":"module"}