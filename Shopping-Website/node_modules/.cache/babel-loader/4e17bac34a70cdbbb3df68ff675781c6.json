{"ast":null,"code":"// Utilities\nimport { convertToUnit, getScrollParents, hasScrollbar, IN_BROWSER, propsFactory } from \"../../util/index.mjs\";\nimport { effectScope, nextTick, onScopeDispose, watchEffect } from 'vue';\nimport { requestNewFrame } from \"./requestNewFrame.mjs\"; // Types\n\nconst scrollStrategies = {\n  none: null,\n  close: closeScrollStrategy,\n  block: blockScrollStrategy,\n  reposition: repositionScrollStrategy\n};\nexport const makeScrollStrategyProps = propsFactory({\n  scrollStrategy: {\n    type: [String, Function],\n    default: 'block',\n    validator: val => typeof val === 'function' || val in scrollStrategies\n  }\n}, 'v-overlay-scroll-strategies');\nexport function useScrollStrategies(props, data) {\n  if (!IN_BROWSER) return;\n  let scope;\n  watchEffect(async () => {\n    scope?.stop();\n    if (!(data.isActive.value && props.scrollStrategy)) return;\n    scope = effectScope();\n    await nextTick();\n    scope.active && scope.run(() => {\n      if (typeof props.scrollStrategy === 'function') {\n        props.scrollStrategy(data, props, scope);\n      } else {\n        scrollStrategies[props.scrollStrategy]?.(data, props, scope);\n      }\n    });\n  });\n  onScopeDispose(() => {\n    scope?.stop();\n  });\n}\n\nfunction closeScrollStrategy(data) {\n  function onScroll(e) {\n    data.isActive.value = false;\n  }\n\n  bindScroll(data.activatorEl.value ?? data.contentEl.value, onScroll);\n}\n\nfunction blockScrollStrategy(data, props) {\n  const offsetParent = data.root.value?.offsetParent;\n  const scrollElements = [...new Set([...getScrollParents(data.activatorEl.value, props.contained ? offsetParent : undefined), ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : undefined)])].filter(el => !el.classList.contains('v-overlay-scroll-blocked'));\n  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;\n\n  const scrollableParent = (el => hasScrollbar(el) && el)(offsetParent || document.documentElement);\n\n  if (scrollableParent) {\n    data.root.value.classList.add('v-overlay--scroll-blocked');\n  }\n\n  scrollElements.forEach((el, i) => {\n    el.style.setProperty('--v-body-scroll-x', convertToUnit(-el.scrollLeft));\n    el.style.setProperty('--v-body-scroll-y', convertToUnit(-el.scrollTop));\n    el.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth));\n    el.classList.add('v-overlay-scroll-blocked');\n  });\n  onScopeDispose(() => {\n    scrollElements.forEach((el, i) => {\n      const x = parseFloat(el.style.getPropertyValue('--v-body-scroll-x'));\n      const y = parseFloat(el.style.getPropertyValue('--v-body-scroll-y'));\n      el.style.removeProperty('--v-body-scroll-x');\n      el.style.removeProperty('--v-body-scroll-y');\n      el.style.removeProperty('--v-scrollbar-offset');\n      el.classList.remove('v-overlay-scroll-blocked');\n      el.scrollLeft = -x;\n      el.scrollTop = -y;\n    });\n\n    if (scrollableParent) {\n      data.root.value.classList.remove('v-overlay--scroll-blocked');\n    }\n  });\n}\n\nfunction repositionScrollStrategy(data, props, scope) {\n  let slow = false;\n  let raf = -1;\n  let ric = -1;\n\n  function update(e) {\n    requestNewFrame(() => {\n      const start = performance.now();\n      data.updateLocation.value?.(e);\n      const time = performance.now() - start;\n      slow = time / (1000 / 60) > 2;\n    });\n  }\n\n  ric = (typeof requestIdleCallback === 'undefined' ? cb => cb() : requestIdleCallback)(() => {\n    scope.run(() => {\n      bindScroll(data.activatorEl.value ?? data.contentEl.value, e => {\n        if (slow) {\n          // If the position calculation is slow,\n          // defer updates until scrolling is finished.\n          // Browsers usually fire one scroll event per frame so\n          // we just wait until we've got two frames without an event\n          cancelAnimationFrame(raf);\n          raf = requestAnimationFrame(() => {\n            raf = requestAnimationFrame(() => {\n              update(e);\n            });\n          });\n        } else {\n          update(e);\n        }\n      });\n    });\n  });\n  onScopeDispose(() => {\n    typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(ric);\n    cancelAnimationFrame(raf);\n  });\n}\n/** @private */\n\n\nfunction bindScroll(el, onScroll) {\n  const scrollElements = [document, ...getScrollParents(el)];\n  scrollElements.forEach(el => {\n    el.addEventListener('scroll', onScroll, {\n      passive: true\n    });\n  });\n  onScopeDispose(() => {\n    scrollElements.forEach(el => {\n      el.removeEventListener('scroll', onScroll);\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["convertToUnit","getScrollParents","hasScrollbar","IN_BROWSER","propsFactory","effectScope","nextTick","onScopeDispose","watchEffect","requestNewFrame","scrollStrategies","none","close","closeScrollStrategy","block","blockScrollStrategy","reposition","repositionScrollStrategy","makeScrollStrategyProps","scrollStrategy","type","String","Function","default","validator","val","useScrollStrategies","props","data","scope","stop","isActive","value","active","run","onScroll","e","bindScroll","activatorEl","contentEl","offsetParent","root","scrollElements","Set","contained","undefined","filter","el","classList","contains","scrollbarWidth","window","innerWidth","document","documentElement","offsetWidth","scrollableParent","add","forEach","i","style","setProperty","scrollLeft","scrollTop","x","parseFloat","getPropertyValue","y","removeProperty","remove","slow","raf","ric","update","start","performance","now","updateLocation","time","requestIdleCallback","cb","cancelAnimationFrame","requestAnimationFrame","cancelIdleCallback","addEventListener","passive","removeEventListener"],"sources":["../../../src/components/VOverlay/scrollStrategies.ts"],"sourcesContent":["// Utilities\nimport { convertToUnit, getScrollParents, hasScrollbar, IN_BROWSER, propsFactory } from '@/util'\nimport { effectScope, nextTick, onScopeDispose, watchEffect } from 'vue'\nimport { requestNewFrame } from './requestNewFrame'\n\n// Types\nimport type { EffectScope, PropType, Ref } from 'vue'\n\nexport interface ScrollStrategyData {\n  root: Ref<HTMLElement | undefined>\n  contentEl: Ref<HTMLElement | undefined>\n  activatorEl: Ref<HTMLElement | undefined>\n  isActive: Ref<boolean>\n  updateLocation: Ref<((e: Event) => void) | undefined>\n}\n\ntype ScrollStrategyFn = (data: ScrollStrategyData, props: StrategyProps, scope: EffectScope) => void\n\nconst scrollStrategies = {\n  none: null,\n  close: closeScrollStrategy,\n  block: blockScrollStrategy,\n  reposition: repositionScrollStrategy,\n}\n\nexport interface StrategyProps {\n  scrollStrategy: keyof typeof scrollStrategies | ScrollStrategyFn\n  contained: boolean | undefined\n}\n\nexport const makeScrollStrategyProps = propsFactory({\n  scrollStrategy: {\n    type: [String, Function] as PropType<StrategyProps['scrollStrategy']>,\n    default: 'block',\n    validator: (val: any) => typeof val === 'function' || val in scrollStrategies,\n  },\n}, 'v-overlay-scroll-strategies')\n\nexport function useScrollStrategies (\n  props: StrategyProps,\n  data: ScrollStrategyData\n) {\n  if (!IN_BROWSER) return\n\n  let scope: EffectScope | undefined\n  watchEffect(async () => {\n    scope?.stop()\n\n    if (!(data.isActive.value && props.scrollStrategy)) return\n\n    scope = effectScope()\n    await nextTick()\n    scope.active && scope.run(() => {\n      if (typeof props.scrollStrategy === 'function') {\n        props.scrollStrategy(data, props, scope!)\n      } else {\n        scrollStrategies[props.scrollStrategy]?.(data, props, scope!)\n      }\n    })\n  })\n\n  onScopeDispose(() => {\n    scope?.stop()\n  })\n}\n\nfunction closeScrollStrategy (data: ScrollStrategyData) {\n  function onScroll (e: Event) {\n    data.isActive.value = false\n  }\n\n  bindScroll(data.activatorEl.value ?? data.contentEl.value, onScroll)\n}\n\nfunction blockScrollStrategy (data: ScrollStrategyData, props: StrategyProps) {\n  const offsetParent = data.root.value?.offsetParent\n  const scrollElements = [...new Set([\n    ...getScrollParents(data.activatorEl.value, props.contained ? offsetParent : undefined),\n    ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : undefined),\n  ])].filter(el => !el.classList.contains('v-overlay-scroll-blocked'))\n  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth\n\n  const scrollableParent = (el => hasScrollbar(el) && el)(offsetParent || document.documentElement)\n  if (scrollableParent) {\n    data.root.value!.classList.add('v-overlay--scroll-blocked')\n  }\n\n  scrollElements.forEach((el, i) => {\n    el.style.setProperty('--v-body-scroll-x', convertToUnit(-el.scrollLeft))\n    el.style.setProperty('--v-body-scroll-y', convertToUnit(-el.scrollTop))\n    el.style.setProperty('--v-scrollbar-offset', convertToUnit(scrollbarWidth))\n    el.classList.add('v-overlay-scroll-blocked')\n  })\n\n  onScopeDispose(() => {\n    scrollElements.forEach((el, i) => {\n      const x = parseFloat(el.style.getPropertyValue('--v-body-scroll-x'))\n      const y = parseFloat(el.style.getPropertyValue('--v-body-scroll-y'))\n\n      el.style.removeProperty('--v-body-scroll-x')\n      el.style.removeProperty('--v-body-scroll-y')\n      el.style.removeProperty('--v-scrollbar-offset')\n      el.classList.remove('v-overlay-scroll-blocked')\n\n      el.scrollLeft = -x\n      el.scrollTop = -y\n    })\n    if (scrollableParent) {\n      data.root.value!.classList.remove('v-overlay--scroll-blocked')\n    }\n  })\n}\n\nfunction repositionScrollStrategy (data: ScrollStrategyData, props: StrategyProps, scope: EffectScope) {\n  let slow = false\n  let raf = -1\n  let ric = -1\n\n  function update (e: Event) {\n    requestNewFrame(() => {\n      const start = performance.now()\n      data.updateLocation.value?.(e)\n      const time = performance.now() - start\n      slow = time / (1000 / 60) > 2\n    })\n  }\n\n  ric = (typeof requestIdleCallback === 'undefined' ? (cb: Function) => cb() : requestIdleCallback)(() => {\n    scope.run(() => {\n      bindScroll(data.activatorEl.value ?? data.contentEl.value, e => {\n        if (slow) {\n          // If the position calculation is slow,\n          // defer updates until scrolling is finished.\n          // Browsers usually fire one scroll event per frame so\n          // we just wait until we've got two frames without an event\n          cancelAnimationFrame(raf)\n          raf = requestAnimationFrame(() => {\n            raf = requestAnimationFrame(() => {\n              update(e)\n            })\n          })\n        } else {\n          update(e)\n        }\n      })\n    })\n  })\n\n  onScopeDispose(() => {\n    typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(ric)\n    cancelAnimationFrame(raf)\n  })\n}\n\n/** @private */\nfunction bindScroll (el: HTMLElement | undefined, onScroll: (e: Event) => void) {\n  const scrollElements = [document, ...getScrollParents(el)]\n  scrollElements.forEach(el => {\n    el.addEventListener('scroll', onScroll, { passive: true })\n  })\n\n  onScopeDispose(() => {\n    scrollElements.forEach(el => {\n      el.removeEventListener('scroll', onScroll)\n    })\n  })\n}\n"]},"metadata":{},"sourceType":"module"}