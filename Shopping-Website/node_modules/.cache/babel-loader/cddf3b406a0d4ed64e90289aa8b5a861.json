{"ast":null,"code":"/* eslint-disable max-statements */\n\n/* eslint-disable no-labels */\n// Utilities\nimport { getPropertyFromItem, propsFactory, wrapInArray } from \"../util/index.mjs\";\nimport { computed, ref, unref, watchEffect } from 'vue'; // Types\n// Composables\n\nexport const defaultFilter = (value, query, item) => {\n  if (value == null || query == null) return -1;\n  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase());\n};\nexport const makeFilterProps = propsFactory({\n  customFilter: Function,\n  customKeyFilter: Object,\n  filterKeys: [Array, String],\n  filterMode: {\n    type: String,\n    default: 'intersection'\n  },\n  noFilter: Boolean\n}, 'filter');\nexport function filterItems(items, query, options) {\n  const array = []; // always ensure we fall back to a functioning filter\n\n  const filter = options?.default ?? defaultFilter;\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false;\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length;\n  if (!items?.length) return array;\n\n  loop: for (let i = 0; i < items.length; i++) {\n    const item = items[i];\n    const customMatches = {};\n    const defaultMatches = {};\n    let match = -1;\n\n    if (query && !options?.noFilter) {\n      if (typeof item === 'object') {\n        const filterKeys = keys || Object.keys(item);\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(item, key, item);\n          const keyFilter = options?.customKeyFilter?.[key];\n          match = keyFilter ? keyFilter(value, query, item) : filter(value, query, item);\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = match;else defaultMatches[key] = match;\n          } else if (options?.filterMode === 'every') {\n            continue loop;\n          }\n        }\n      } else {\n        match = filter(item, query, item);\n\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = match;\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length;\n      const customMatchesLength = Object.keys(customMatches).length;\n      if (!defaultMatchesLength && !customMatchesLength) continue;\n      if (options?.filterMode === 'union' && customMatchesLength !== customFiltersLength && !defaultMatchesLength) continue;\n      if (options?.filterMode === 'intersection' && (customMatchesLength !== customFiltersLength || !defaultMatchesLength)) continue;\n    }\n\n    array.push({\n      index: i,\n      matches: { ...defaultMatches,\n        ...customMatches\n      }\n    });\n  }\n\n  return array;\n}\nexport function useFilter(props, items, query, options) {\n  const strQuery = computed(() => typeof query?.value !== 'string' && typeof query?.value !== 'number' ? '' : String(query.value));\n  const filteredItems = ref([]);\n  const filteredMatches = ref(new Map());\n  watchEffect(() => {\n    filteredItems.value = [];\n    filteredMatches.value = new Map();\n    const transformedItems = unref(items);\n    const results = filterItems(transformedItems, strQuery.value, {\n      customKeyFilter: props.customKeyFilter,\n      default: props.customFilter,\n      filterKeys: unref(options?.filterKeys) ?? props.filterKeys,\n      filterMode: props.filterMode,\n      noFilter: props.noFilter\n    });\n    results.forEach(_ref => {\n      let {\n        index,\n        matches\n      } = _ref;\n      const item = transformedItems[index];\n      filteredItems.value.push(item);\n      filteredMatches.value.set(item.value, matches);\n    });\n  });\n\n  function getMatches(item) {\n    return filteredMatches.value.get(item.value);\n  }\n\n  return {\n    filteredItems,\n    filteredMatches,\n    getMatches\n  };\n}","map":{"version":3,"mappings":"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","names":["getPropertyFromItem","propsFactory","wrapInArray","computed","ref","unref","watchEffect","defaultFilter","value","query","item","toString","toLocaleLowerCase","indexOf","makeFilterProps","customFilter","Function","customKeyFilter","Object","filterKeys","Array","String","filterMode","type","default","noFilter","Boolean","filterItems","items","options","array","filter","keys","customFiltersLength","length","loop","i","customMatches","defaultMatches","match","key","keyFilter","title","defaultMatchesLength","customMatchesLength","push","index","matches","useFilter","props","strQuery","filteredItems","filteredMatches","Map","transformedItems","results","forEach","_ref","set","getMatches","get"],"sources":["../../src/composables/filter.ts"],"sourcesContent":["/* eslint-disable max-statements */\n/* eslint-disable no-labels */\n\n// Utilities\nimport { getPropertyFromItem, propsFactory, wrapInArray } from '@/util'\nimport { computed, ref, unref, watchEffect } from 'vue'\n\n// Types\nimport type { PropType, Ref } from 'vue'\nimport type { MaybeRef } from '@/util'\nimport type { InternalItem } from './items'\n\n/**\n * - match without highlight\n * - single match (index), length already known\n * - single match (start, end)\n * - multiple matches (start, end), probably shouldn't overlap\n */\nexport type FilterMatch = boolean | number | [number, number] | [number, number][]\nexport type FilterFunction = (value: string, query: string, item?: any) => FilterMatch\nexport type FilterKeyFunctions = Record<string, FilterFunction>\nexport type FilterKeys = string | string[]\nexport type FilterMode = 'some' | 'every' | 'union' | 'intersection'\n\nexport interface FilterProps {\n  customFilter?: FilterFunction\n  customKeyFilter?: FilterKeyFunctions\n  filterKeys?: FilterKeys\n  filterMode?: FilterMode\n  noFilter?: boolean\n}\n\n// Composables\nexport const defaultFilter: FilterFunction = (value, query, item) => {\n  if (value == null || query == null) return -1\n\n  return value.toString().toLocaleLowerCase().indexOf(query.toString().toLocaleLowerCase())\n}\n\nexport const makeFilterProps = propsFactory({\n  customFilter: Function as PropType<FilterFunction>,\n  customKeyFilter: Object as PropType<FilterKeyFunctions>,\n  filterKeys: [Array, String] as PropType<FilterKeys>,\n  filterMode: {\n    type: String as PropType<FilterMode>,\n    default: 'intersection',\n  },\n  noFilter: Boolean,\n}, 'filter')\n\nexport function filterItems (\n  items: InternalItem[],\n  query: string,\n  options?: {\n    customKeyFilter?: FilterKeyFunctions\n    default?: FilterFunction\n    filterKeys?: FilterKeys\n    filterMode?: FilterMode\n    noFilter?: boolean\n  },\n) {\n  const array: { index: number, matches: Record<string, FilterMatch> }[] = []\n  // always ensure we fall back to a functioning filter\n  const filter = options?.default ?? defaultFilter\n  const keys = options?.filterKeys ? wrapInArray(options.filterKeys) : false\n  const customFiltersLength = Object.keys(options?.customKeyFilter ?? {}).length\n\n  if (!items?.length) return array\n\n  loop:\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i]\n    const customMatches: Record<string, FilterMatch> = {}\n    const defaultMatches: Record<string, FilterMatch> = {}\n    let match: FilterMatch = -1\n\n    if (query && !options?.noFilter) {\n      if (typeof item === 'object') {\n        const filterKeys = keys || Object.keys(item)\n\n        for (const key of filterKeys) {\n          const value = getPropertyFromItem(item as any, key, item)\n          const keyFilter = options?.customKeyFilter?.[key]\n\n          match = keyFilter\n            ? keyFilter(value, query, item)\n            : filter(value, query, item)\n\n          if (match !== -1 && match !== false) {\n            if (keyFilter) customMatches[key] = match\n            else defaultMatches[key] = match\n          } else if (options?.filterMode === 'every') {\n            continue loop\n          }\n        }\n      } else {\n        match = filter(item, query, item)\n        if (match !== -1 && match !== false) {\n          defaultMatches.title = match\n        }\n      }\n\n      const defaultMatchesLength = Object.keys(defaultMatches).length\n      const customMatchesLength = Object.keys(customMatches).length\n\n      if (!defaultMatchesLength && !customMatchesLength) continue\n\n      if (\n        options?.filterMode === 'union' &&\n        customMatchesLength !== customFiltersLength &&\n        !defaultMatchesLength\n      ) continue\n\n      if (\n        options?.filterMode === 'intersection' &&\n        (\n          customMatchesLength !== customFiltersLength ||\n          !defaultMatchesLength\n        )\n      ) continue\n    }\n\n    array.push({ index: i, matches: { ...defaultMatches, ...customMatches } })\n  }\n\n  return array\n}\n\nexport function useFilter <T extends InternalItem> (\n  props: FilterProps,\n  items: MaybeRef<T[]>,\n  query: Ref<string | undefined>,\n  options?: {\n    filterKeys?: MaybeRef<FilterKeys>\n  }\n) {\n  const strQuery = computed(() => (\n    typeof query?.value !== 'string' &&\n    typeof query?.value !== 'number'\n  ) ? '' : String(query.value))\n\n  const filteredItems: Ref<T[]> = ref([])\n  const filteredMatches: Ref<Map<unknown, Record<string, FilterMatch>>> = ref(new Map())\n\n  watchEffect(() => {\n    filteredItems.value = []\n    filteredMatches.value = new Map()\n\n    const transformedItems = unref(items)\n    const results = filterItems(\n      transformedItems,\n      strQuery.value,\n      {\n        customKeyFilter: props.customKeyFilter,\n        default: props.customFilter,\n        filterKeys: unref(options?.filterKeys) ?? props.filterKeys,\n        filterMode: props.filterMode,\n        noFilter: props.noFilter,\n      },\n    )\n\n    results.forEach(({ index, matches }) => {\n      const item = transformedItems[index]\n      filteredItems.value.push(item)\n      filteredMatches.value.set(item.value, matches)\n    })\n  })\n\n  function getMatches (item: T) {\n    return filteredMatches.value.get(item.value)\n  }\n\n  return { filteredItems, filteredMatches, getMatches }\n}\n"]},"metadata":{},"sourceType":"module"}