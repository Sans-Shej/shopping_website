{"ast":null,"code":"import { withDirectives as _withDirectives, resolveDirective as _resolveDirective, Fragment as _Fragment, createVNode as _createVNode } from \"vue\";\nimport \"./VImg.css\"; // Components\n\nimport { VResponsive } from \"../VResponsive/index.mjs\"; // Directives\n\nimport intersect from \"../../directives/intersect/index.mjs\"; // Composables\n\nimport { makeTransitionProps, MaybeTransition } from \"../../composables/transition.mjs\"; // Utilities\n\nimport { computed, nextTick, onBeforeMount, ref, vShow, watch, withDirectives } from 'vue';\nimport { convertToUnit, genericComponent, SUPPORTS_INTERSECTION, useRender } from \"../../util/index.mjs\"; // Types\n\nexport const VImg = genericComponent()({\n  name: 'VImg',\n  directives: {\n    intersect\n  },\n  props: {\n    aspectRatio: [String, Number],\n    alt: String,\n    cover: Boolean,\n    eager: Boolean,\n    gradient: String,\n    lazySrc: String,\n    options: {\n      type: Object,\n      // For more information on types, navigate to:\n      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n      default: () => ({\n        root: undefined,\n        rootMargin: undefined,\n        threshold: undefined\n      })\n    },\n    sizes: String,\n    src: {\n      type: [String, Object],\n      default: ''\n    },\n    srcset: String,\n    width: [String, Number],\n    ...makeTransitionProps()\n  },\n  emits: {\n    loadstart: value => true,\n    load: value => true,\n    error: value => true\n  },\n\n  setup(props, _ref) {\n    let {\n      emit,\n      slots\n    } = _ref;\n    const currentSrc = ref(''); // Set from srcset\n\n    const image = ref();\n    const state = ref(props.eager ? 'loading' : 'idle');\n    const naturalWidth = ref();\n    const naturalHeight = ref();\n    const normalisedSrc = computed(() => {\n      return props.src && typeof props.src === 'object' ? {\n        src: props.src.src,\n        srcset: props.srcset || props.src.srcset,\n        lazySrc: props.lazySrc || props.src.lazySrc,\n        aspect: Number(props.aspectRatio || props.src.aspect || 0)\n      } : {\n        src: props.src,\n        srcset: props.srcset,\n        lazySrc: props.lazySrc,\n        aspect: Number(props.aspectRatio || 0)\n      };\n    });\n    const aspectRatio = computed(() => {\n      return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;\n    });\n    watch(() => props.src, () => {\n      init(state.value !== 'idle');\n    });\n    watch(aspectRatio, (val, oldVal) => {\n      if (!val && oldVal && image.value) {\n        pollForSize(image.value);\n      }\n    }); // TODO: getSrc when window width changes\n\n    onBeforeMount(() => init());\n\n    function init(isIntersecting) {\n      if (props.eager && isIntersecting) return;\n      if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager) return;\n      state.value = 'loading';\n\n      if (normalisedSrc.value.lazySrc) {\n        const lazyImg = new Image();\n        lazyImg.src = normalisedSrc.value.lazySrc;\n        pollForSize(lazyImg, null);\n      }\n\n      if (!normalisedSrc.value.src) return;\n      nextTick(() => {\n        emit('loadstart', image.value?.currentSrc || normalisedSrc.value.src);\n\n        if (image.value?.complete) {\n          if (!image.value.naturalWidth) {\n            onError();\n          }\n\n          if (state.value === 'error') return;\n          if (!aspectRatio.value) pollForSize(image.value, null);\n          onLoad();\n        } else {\n          if (!aspectRatio.value) pollForSize(image.value);\n          getSrc();\n        }\n      });\n    }\n\n    function onLoad() {\n      getSrc();\n      state.value = 'loaded';\n      emit('load', image.value?.currentSrc || normalisedSrc.value.src);\n    }\n\n    function onError() {\n      state.value = 'error';\n      emit('error', image.value?.currentSrc || normalisedSrc.value.src);\n    }\n\n    function getSrc() {\n      const img = image.value;\n      if (img) currentSrc.value = img.currentSrc || img.src;\n    }\n\n    let timer = -1;\n\n    function pollForSize(img) {\n      let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n\n      const poll = () => {\n        clearTimeout(timer);\n        const {\n          naturalHeight: imgHeight,\n          naturalWidth: imgWidth\n        } = img;\n\n        if (imgHeight || imgWidth) {\n          naturalWidth.value = imgWidth;\n          naturalHeight.value = imgHeight;\n        } else if (!img.complete && state.value === 'loading' && timeout != null) {\n          timer = window.setTimeout(poll, timeout);\n        } else if (img.currentSrc.endsWith('.svg') || img.currentSrc.startsWith('data:image/svg+xml')) {\n          naturalWidth.value = 1;\n          naturalHeight.value = 1;\n        }\n      };\n\n      poll();\n    }\n\n    const containClasses = computed(() => ({\n      'v-img__img--cover': props.cover,\n      'v-img__img--contain': !props.cover\n    }));\n\n    const __image = () => {\n      if (!normalisedSrc.value.src || state.value === 'idle') return null;\n\n      const img = _createVNode(\"img\", {\n        \"class\": ['v-img__img', containClasses.value],\n        \"src\": normalisedSrc.value.src,\n        \"srcset\": normalisedSrc.value.srcset,\n        \"alt\": props.alt,\n        \"sizes\": props.sizes,\n        \"ref\": image,\n        \"onLoad\": onLoad,\n        \"onError\": onError\n      }, null);\n\n      const sources = slots.sources?.();\n      return _createVNode(MaybeTransition, {\n        \"transition\": props.transition,\n        \"appear\": true\n      }, {\n        default: () => [withDirectives(sources ? _createVNode(\"picture\", {\n          \"class\": \"v-img__picture\"\n        }, [sources, img]) : img, [[vShow, state.value === 'loaded']])]\n      });\n    };\n\n    const __preloadImage = () => _createVNode(MaybeTransition, {\n      \"transition\": props.transition\n    }, {\n      default: () => [normalisedSrc.value.lazySrc && state.value !== 'loaded' && _createVNode(\"img\", {\n        \"class\": ['v-img__img', 'v-img__img--preload', containClasses.value],\n        \"src\": normalisedSrc.value.lazySrc,\n        \"alt\": props.alt\n      }, null)]\n    });\n\n    const __placeholder = () => {\n      if (!slots.placeholder) return null;\n      return _createVNode(MaybeTransition, {\n        \"transition\": props.transition,\n        \"appear\": true\n      }, {\n        default: () => [(state.value === 'loading' || state.value === 'error' && !slots.error) && _createVNode(\"div\", {\n          \"class\": \"v-img__placeholder\"\n        }, [slots.placeholder()])]\n      });\n    };\n\n    const __error = () => {\n      if (!slots.error) return null;\n      return _createVNode(MaybeTransition, {\n        \"transition\": props.transition,\n        \"appear\": true\n      }, {\n        default: () => [state.value === 'error' && _createVNode(\"div\", {\n          \"class\": \"v-img__error\"\n        }, [slots.error()])]\n      });\n    };\n\n    const __gradient = () => {\n      if (!props.gradient) return null;\n      return _createVNode(\"div\", {\n        \"class\": \"v-img__gradient\",\n        \"style\": {\n          backgroundImage: `linear-gradient(${props.gradient})`\n        }\n      }, null);\n    };\n\n    const isBooted = ref(false);\n    {\n      const stop = watch(aspectRatio, val => {\n        if (val) {\n          // Doesn't work with nextTick, idk why\n          requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n              isBooted.value = true;\n            });\n          });\n          stop();\n        }\n      });\n    }\n    useRender(() => _withDirectives(_createVNode(VResponsive, {\n      \"class\": ['v-img', {\n        'v-img--booting': !isBooted.value\n      }],\n      \"style\": {\n        width: convertToUnit(props.width === 'auto' ? naturalWidth.value : props.width)\n      },\n      \"aspectRatio\": aspectRatio.value,\n      \"aria-label\": props.alt,\n      \"role\": props.alt ? 'img' : undefined\n    }, {\n      additional: () => _createVNode(_Fragment, null, [_createVNode(__image, null, null), _createVNode(__preloadImage, null, null), _createVNode(__gradient, null, null), _createVNode(__placeholder, null, null), _createVNode(__error, null, null)]),\n      default: slots.default\n    }), [[_resolveDirective(\"intersect\"), {\n      handler: init,\n      options: props.options\n    }, null, {\n      once: true\n    }]]));\n    return {\n      currentSrc,\n      image,\n      state,\n      naturalWidth,\n      naturalHeight\n    };\n  }\n\n});","map":{"version":3,"mappings":"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","names":["VResponsive","intersect","makeTransitionProps","MaybeTransition","computed","nextTick","onBeforeMount","ref","vShow","watch","withDirectives","convertToUnit","genericComponent","SUPPORTS_INTERSECTION","useRender","VImg","name","directives","props","aspectRatio","String","Number","alt","cover","Boolean","eager","gradient","lazySrc","options","type","Object","default","root","undefined","rootMargin","threshold","sizes","src","srcset","width","emits","loadstart","value","load","error","setup","_ref","emit","slots","currentSrc","image","state","naturalWidth","naturalHeight","normalisedSrc","aspect","init","val","oldVal","pollForSize","isIntersecting","lazyImg","Image","complete","onError","onLoad","getSrc","img","timer","timeout","poll","clearTimeout","imgHeight","imgWidth","window","setTimeout","endsWith","startsWith","containClasses","__image","sources","transition","__preloadImage","_createVNode","__placeholder","placeholder","__error","__gradient","backgroundImage","isBooted","stop","requestAnimationFrame","additional","handler","once"],"sources":["../../../src/components/VImg/VImg.tsx"],"sourcesContent":["import './VImg.sass'\n\n// Components\nimport { VResponsive } from '@/components/VResponsive'\n\n// Directives\nimport intersect from '@/directives/intersect'\n\n// Composables\nimport { makeTransitionProps, MaybeTransition } from '@/composables/transition'\n\n// Utilities\nimport {\n  computed,\n  nextTick,\n  onBeforeMount,\n  ref,\n  vShow,\n  watch,\n  withDirectives,\n} from 'vue'\nimport {\n  convertToUnit,\n  genericComponent,\n  SUPPORTS_INTERSECTION,\n  useRender,\n} from '@/util'\n\n// Types\nimport type { PropType } from 'vue'\n\n// not intended for public use, this is passed in by vuetify-loader\nexport interface srcObject {\n  src?: string\n  srcset?: string\n  lazySrc?: string\n  aspect: number\n}\n\nexport type VImgSlots = {\n  default: []\n  placeholder: []\n  error: []\n  sources: []\n}\n\nexport const VImg = genericComponent<VImgSlots>()({\n  name: 'VImg',\n\n  directives: { intersect },\n\n  props: {\n    aspectRatio: [String, Number],\n    alt: String,\n    cover: Boolean,\n    eager: Boolean,\n    gradient: String,\n    lazySrc: String,\n    options: {\n      type: Object as PropType<IntersectionObserverInit>,\n      // For more information on types, navigate to:\n      // https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n      default: () => ({\n        root: undefined,\n        rootMargin: undefined,\n        threshold: undefined,\n      }),\n    },\n    sizes: String,\n    src: {\n      type: [String, Object] as PropType<string | srcObject>,\n      default: '',\n    },\n    srcset: String,\n    width: [String, Number],\n\n    ...makeTransitionProps(),\n  },\n\n  emits: {\n    loadstart: (value: string | undefined) => true,\n    load: (value: string | undefined) => true,\n    error: (value: string | undefined) => true,\n  },\n\n  setup (props, { emit, slots }) {\n    const currentSrc = ref('') // Set from srcset\n    const image = ref<HTMLImageElement>()\n    const state = ref<'idle' | 'loading' | 'loaded' | 'error'>(props.eager ? 'loading' : 'idle')\n    const naturalWidth = ref<number>()\n    const naturalHeight = ref<number>()\n\n    const normalisedSrc = computed<srcObject>(() => {\n      return props.src && typeof props.src === 'object'\n        ? {\n          src: props.src.src,\n          srcset: props.srcset || props.src.srcset,\n          lazySrc: props.lazySrc || props.src.lazySrc,\n          aspect: Number(props.aspectRatio || props.src.aspect || 0),\n        } : {\n          src: props.src,\n          srcset: props.srcset,\n          lazySrc: props.lazySrc,\n          aspect: Number(props.aspectRatio || 0),\n        }\n    })\n    const aspectRatio = computed(() => {\n      return normalisedSrc.value.aspect || naturalWidth.value! / naturalHeight.value! || 0\n    })\n\n    watch(() => props.src, () => {\n      init(state.value !== 'idle')\n    })\n    watch(aspectRatio, (val, oldVal) => {\n      if (!val && oldVal && image.value) {\n        pollForSize(image.value)\n      }\n    })\n\n    // TODO: getSrc when window width changes\n\n    onBeforeMount(() => init())\n\n    function init (isIntersecting?: boolean) {\n      if (props.eager && isIntersecting) return\n      if (\n        SUPPORTS_INTERSECTION &&\n        !isIntersecting &&\n        !props.eager\n      ) return\n\n      state.value = 'loading'\n\n      if (normalisedSrc.value.lazySrc) {\n        const lazyImg = new Image()\n        lazyImg.src = normalisedSrc.value.lazySrc\n        pollForSize(lazyImg, null)\n      }\n\n      if (!normalisedSrc.value.src) return\n\n      nextTick(() => {\n        emit('loadstart', image.value?.currentSrc || normalisedSrc.value.src)\n\n        if (image.value?.complete) {\n          if (!image.value.naturalWidth) {\n            onError()\n          }\n\n          if (state.value === 'error') return\n\n          if (!aspectRatio.value) pollForSize(image.value, null)\n          onLoad()\n        } else {\n          if (!aspectRatio.value) pollForSize(image.value!)\n          getSrc()\n        }\n      })\n    }\n\n    function onLoad () {\n      getSrc()\n      state.value = 'loaded'\n      emit('load', image.value?.currentSrc || normalisedSrc.value.src)\n    }\n\n    function onError () {\n      state.value = 'error'\n      emit('error', image.value?.currentSrc || normalisedSrc.value.src)\n    }\n\n    function getSrc () {\n      const img = image.value\n      if (img) currentSrc.value = img.currentSrc || img.src\n    }\n\n    let timer = -1\n    function pollForSize (img: HTMLImageElement, timeout: number | null = 100) {\n      const poll = () => {\n        clearTimeout(timer)\n        const { naturalHeight: imgHeight, naturalWidth: imgWidth } = img\n\n        if (imgHeight || imgWidth) {\n          naturalWidth.value = imgWidth\n          naturalHeight.value = imgHeight\n        } else if (!img.complete && state.value === 'loading' && timeout != null) {\n          timer = window.setTimeout(poll, timeout)\n        } else if (img.currentSrc.endsWith('.svg') || img.currentSrc.startsWith('data:image/svg+xml')) {\n          naturalWidth.value = 1\n          naturalHeight.value = 1\n        }\n      }\n\n      poll()\n    }\n\n    const containClasses = computed(() => ({\n      'v-img__img--cover': props.cover,\n      'v-img__img--contain': !props.cover,\n    }))\n\n    const __image = () => {\n      if (!normalisedSrc.value.src || state.value === 'idle') return null\n\n      const img = (\n        <img\n          class={['v-img__img', containClasses.value]}\n          src={ normalisedSrc.value.src }\n          srcset={ normalisedSrc.value.srcset }\n          alt={ props.alt }\n          sizes={ props.sizes }\n          ref={ image }\n          onLoad={ onLoad }\n          onError={ onError }\n        />\n      )\n\n      const sources = slots.sources?.()\n\n      return (\n        <MaybeTransition transition={ props.transition } appear>\n          {\n            withDirectives(\n              sources\n                ? <picture class=\"v-img__picture\">{ sources }{ img }</picture>\n                : img,\n              [[vShow, state.value === 'loaded']]\n            )\n          }\n        </MaybeTransition>\n      )\n    }\n\n    const __preloadImage = () => (\n      <MaybeTransition transition={ props.transition }>\n        { normalisedSrc.value.lazySrc && state.value !== 'loaded' && (\n          <img\n            class={['v-img__img', 'v-img__img--preload', containClasses.value]}\n            src={ normalisedSrc.value.lazySrc }\n            alt={ props.alt }\n          />\n        )}\n      </MaybeTransition>\n    )\n\n    const __placeholder = () => {\n      if (!slots.placeholder) return null\n\n      return (\n        <MaybeTransition transition={ props.transition } appear>\n          { (state.value === 'loading' || (state.value === 'error' && !slots.error)) &&\n          <div class=\"v-img__placeholder\">{ slots.placeholder() }</div>\n          }\n        </MaybeTransition>\n      )\n    }\n\n    const __error = () => {\n      if (!slots.error) return null\n\n      return (\n        <MaybeTransition transition={ props.transition } appear>\n          { state.value === 'error' &&\n            <div class=\"v-img__error\">{ slots.error() }</div>\n          }\n        </MaybeTransition>\n      )\n    }\n\n    const __gradient = () => {\n      if (!props.gradient) return null\n\n      return <div class=\"v-img__gradient\" style={{ backgroundImage: `linear-gradient(${props.gradient})` }} />\n    }\n\n    const isBooted = ref(false)\n    {\n      const stop = watch(aspectRatio, val => {\n        if (val) {\n          // Doesn't work with nextTick, idk why\n          requestAnimationFrame(() => {\n            requestAnimationFrame(() => {\n              isBooted.value = true\n            })\n          })\n          stop()\n        }\n      })\n    }\n\n    useRender(() => (\n      <VResponsive\n        class={[\n          'v-img',\n          { 'v-img--booting': !isBooted.value },\n        ]}\n        style={{ width: convertToUnit(props.width === 'auto' ? naturalWidth.value : props.width) }}\n        aspectRatio={ aspectRatio.value }\n        aria-label={ props.alt }\n        role={ props.alt ? 'img' : undefined }\n        v-intersect={[{\n          handler: init,\n          options: props.options,\n        }, null, ['once']]}\n      >{{\n        additional: () => (\n          <>\n            <__image />\n            <__preloadImage />\n            <__gradient />\n            <__placeholder />\n            <__error />\n          </>\n        ),\n        default: slots.default,\n      }}</VResponsive>\n    ))\n\n    return {\n      currentSrc,\n      image,\n      state,\n      naturalWidth,\n      naturalHeight,\n    }\n  },\n})\n\nexport type VImg = InstanceType<typeof VImg>\n"]},"metadata":{},"sourceType":"module"}