{"ast":null,"code":"import { useProxiedModel } from \"../proxiedModel.mjs\";\nimport { getCurrentInstance, getUid, propsFactory } from \"../../util/index.mjs\";\nimport { computed, inject, onBeforeUnmount, provide, ref, toRaw } from 'vue';\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from \"./openStrategies.mjs\";\nimport { classicSelectStrategy, independentSelectStrategy, independentSingleSelectStrategy, leafSelectStrategy, leafSingleSelectStrategy } from \"./selectStrategies.mjs\"; // Types\n\nexport const VNestedSymbol = Symbol.for('vuetify:nested');\nexport const emptyNested = {\n  id: ref(),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    openOnSelect: () => null,\n    select: () => null,\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([])\n  }\n};\nexport const makeNestedProps = propsFactory({\n  selectStrategy: [String, Function],\n  openStrategy: [String, Object],\n  opened: Array,\n  selected: Array,\n  mandatory: Boolean\n}, 'nested');\nexport const useNested = props => {\n  let isUnmounted = false;\n  const children = ref(new Map());\n  const parents = ref(new Map());\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()]);\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy;\n\n    switch (props.selectStrategy) {\n      case 'single-leaf':\n        return leafSingleSelectStrategy(props.mandatory);\n\n      case 'leaf':\n        return leafSelectStrategy(props.mandatory);\n\n      case 'independent':\n        return independentSelectStrategy(props.mandatory);\n\n      case 'single-independent':\n        return independentSingleSelectStrategy(props.mandatory);\n\n      case 'classic':\n      default:\n        return classicSelectStrategy(props.mandatory);\n    }\n  });\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'object') return props.openStrategy;\n\n    switch (props.openStrategy) {\n      case 'list':\n        return listOpenStrategy;\n\n      case 'single':\n        return singleOpenStrategy;\n\n      case 'multiple':\n      default:\n        return multipleOpenStrategy;\n    }\n  });\n  const selected = useProxiedModel(props, 'selected', props.selected, v => selectStrategy.value.in(v, children.value, parents.value), v => selectStrategy.value.out(v, children.value, parents.value));\n  onBeforeUnmount(() => {\n    isUnmounted = true;\n  });\n\n  function getPath(id) {\n    const path = [];\n    let parent = id;\n\n    while (parent != null) {\n      path.unshift(parent);\n      parent = parents.value.get(parent);\n    }\n\n    return path;\n  }\n\n  const vm = getCurrentInstance('nested');\n  const nested = {\n    id: ref(),\n    root: {\n      opened,\n      selected,\n      selectedValues: computed(() => {\n        const arr = [];\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key);\n        }\n\n        return arr;\n      }),\n      register: (id, parentId, isGroup) => {\n        parentId && id !== parentId && parents.value.set(id, parentId);\n        isGroup && children.value.set(id, []);\n\n        if (parentId != null) {\n          children.value.set(parentId, [...(children.value.get(parentId) || []), id]);\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return;\n        children.value.delete(id);\n        const parent = parents.value.get(id);\n\n        if (parent) {\n          const list = children.value.get(parent) ?? [];\n          children.value.set(parent, list.filter(child => child !== id));\n        }\n\n        parents.value.delete(id);\n        opened.value.delete(id);\n      },\n      open: (id, value, event) => {\n        vm.emit('click:open', {\n          id,\n          value,\n          path: getPath(id),\n          event\n        });\n        const newOpened = openStrategy.value.open({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      openOnSelect: (id, value, event) => {\n        const newOpened = openStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event\n        });\n        newOpened && (opened.value = newOpened);\n      },\n      select: (id, value, event) => {\n        vm.emit('click:select', {\n          id,\n          value,\n          path: getPath(id),\n          event\n        });\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event\n        });\n        newSelected && (selected.value = newSelected);\n        nested.root.openOnSelect(id, value, event);\n      },\n      children,\n      parents\n    }\n  };\n  provide(VNestedSymbol, nested);\n  return nested.root;\n};\nexport const useNestedItem = (id, isGroup) => {\n  const parent = inject(VNestedSymbol, emptyNested);\n  const uidSymbol = Symbol(getUid());\n  const computedId = computed(() => id.value ?? uidSymbol);\n  const item = { ...parent,\n    id: computedId,\n    open: (open, e) => parent.root.open(computedId.value, open, e),\n    openOnSelect: (open, e) => parent.root.openOnSelect(computedId.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    select: (selected, e) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === 'indeterminate'),\n    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),\n    isGroupActivator: parent.isGroupActivator\n  };\n  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);\n  onBeforeUnmount(() => {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value);\n  });\n  isGroup && provide(VNestedSymbol, item);\n  return item;\n};\nexport const useNestedGroupActivator = () => {\n  const parent = inject(VNestedSymbol, emptyNested);\n  provide(VNestedSymbol, { ...parent,\n    isGroupActivator: true\n  });\n};","map":{"version":3,"mappings":"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","names":["useProxiedModel","getCurrentInstance","getUid","propsFactory","computed","inject","onBeforeUnmount","provide","ref","toRaw","listOpenStrategy","multipleOpenStrategy","singleOpenStrategy","classicSelectStrategy","independentSelectStrategy","independentSingleSelectStrategy","leafSelectStrategy","leafSingleSelectStrategy","VNestedSymbol","Symbol","for","emptyNested","id","root","register","unregister","parents","Map","children","open","openOnSelect","select","opened","Set","selected","selectedValues","makeNestedProps","selectStrategy","String","Function","openStrategy","Object","Array","mandatory","Boolean","useNested","props","isUnmounted","v","values","value","in","out","getPath","path","parent","unshift","get","vm","nested","arr","key","entries","push","parentId","isGroup","set","delete","list","filter","child","event","emit","newOpened","newSelected","useNestedItem","uidSymbol","computedId","item","e","isOpen","has","isSelected","isIndeterminate","isLeaf","isGroupActivator","useNestedGroupActivator"],"sources":["../../../src/composables/nested/nested.ts"],"sourcesContent":["import { useProxiedModel } from '@/composables/proxiedModel'\nimport { getCurrentInstance, getUid, propsFactory } from '@/util'\nimport { computed, inject, onBeforeUnmount, provide, ref, toRaw } from 'vue'\nimport { listOpenStrategy, multipleOpenStrategy, singleOpenStrategy } from './openStrategies'\nimport {\n  classicSelectStrategy,\n  independentSelectStrategy,\n  independentSingleSelectStrategy,\n  leafSelectStrategy,\n  leafSingleSelectStrategy,\n} from './selectStrategies'\n\n// Types\nimport type { InjectionKey, PropType, Ref } from 'vue'\nimport type { SelectStrategyFn } from './selectStrategies'\nimport type { OpenStrategy } from './openStrategies'\n\nexport type SelectStrategy = 'single-leaf' | 'leaf' | 'independent' | 'single-independent' | 'classic' | SelectStrategyFn\nexport type OpenStrategyProp = 'single' | 'multiple' | 'list' | OpenStrategy\n\nexport interface NestedProps {\n  selectStrategy: SelectStrategy | undefined\n  openStrategy: OpenStrategyProp | undefined\n  selected: unknown[] | undefined\n  opened: unknown[] | undefined\n  mandatory: boolean\n  'onUpdate:selected': ((val: unknown[]) => void) | undefined\n  'onUpdate:opened': ((val: unknown[]) => void) | undefined\n}\n\ntype NestedProvide = {\n  id: Ref<unknown>\n  isGroupActivator?: boolean\n  root: {\n    children: Ref<Map<unknown, unknown[]>>\n    parents: Ref<Map<unknown, unknown>>\n    opened: Ref<Set<unknown>>\n    selected: Ref<Map<unknown, 'on' | 'off' | 'indeterminate'>>\n    selectedValues: Ref<unknown[]>\n    register: (id: unknown, parentId: unknown, isGroup?: boolean) => void\n    unregister: (id: unknown) => void\n    open: (id: unknown, value: boolean, event?: Event) => void\n    select: (id: unknown, value: boolean, event?: Event) => void\n    openOnSelect: (id: unknown, value: boolean, event?: Event) => void\n  }\n}\n\nexport const VNestedSymbol: InjectionKey<NestedProvide> = Symbol.for('vuetify:nested')\n\nexport const emptyNested: NestedProvide = {\n  id: ref(),\n  root: {\n    register: () => null,\n    unregister: () => null,\n    parents: ref(new Map()),\n    children: ref(new Map()),\n    open: () => null,\n    openOnSelect: () => null,\n    select: () => null,\n    opened: ref(new Set()),\n    selected: ref(new Map()),\n    selectedValues: ref([]),\n  },\n}\n\nexport const makeNestedProps = propsFactory({\n  selectStrategy: [String, Function] as PropType<SelectStrategy>,\n  openStrategy: [String, Object] as PropType<OpenStrategyProp>,\n  opened: Array as PropType<unknown[]>,\n  selected: Array as PropType<unknown[]>,\n  mandatory: Boolean,\n}, 'nested')\n\nexport const useNested = (props: NestedProps) => {\n  let isUnmounted = false\n  const children = ref(new Map<unknown, unknown[]>())\n  const parents = ref(new Map<unknown, unknown>())\n\n  const opened = useProxiedModel(props, 'opened', props.opened, v => new Set(v), v => [...v.values()])\n\n  const selectStrategy = computed(() => {\n    if (typeof props.selectStrategy === 'object') return props.selectStrategy\n\n    switch (props.selectStrategy) {\n      case 'single-leaf': return leafSingleSelectStrategy(props.mandatory)\n      case 'leaf': return leafSelectStrategy(props.mandatory)\n      case 'independent': return independentSelectStrategy(props.mandatory)\n      case 'single-independent': return independentSingleSelectStrategy(props.mandatory)\n      case 'classic':\n      default: return classicSelectStrategy(props.mandatory)\n    }\n  })\n\n  const openStrategy = computed(() => {\n    if (typeof props.openStrategy === 'object') return props.openStrategy\n\n    switch (props.openStrategy) {\n      case 'list': return listOpenStrategy\n      case 'single': return singleOpenStrategy\n      case 'multiple':\n      default: return multipleOpenStrategy\n    }\n  })\n\n  const selected = useProxiedModel(\n    props,\n    'selected',\n    props.selected,\n    v => selectStrategy.value.in(v, children.value, parents.value),\n    v => selectStrategy.value.out(v, children.value, parents.value),\n  )\n\n  onBeforeUnmount(() => {\n    isUnmounted = true\n  })\n\n  function getPath (id: unknown) {\n    const path: unknown[] = []\n    let parent: unknown = id\n\n    while (parent != null) {\n      path.unshift(parent)\n      parent = parents.value.get(parent)\n    }\n\n    return path\n  }\n\n  const vm = getCurrentInstance('nested')\n\n  const nested: NestedProvide = {\n    id: ref(),\n    root: {\n      opened,\n      selected,\n      selectedValues: computed(() => {\n        const arr = []\n\n        for (const [key, value] of selected.value.entries()) {\n          if (value === 'on') arr.push(key)\n        }\n\n        return arr\n      }),\n      register: (id, parentId, isGroup) => {\n        parentId && id !== parentId && parents.value.set(id, parentId)\n\n        isGroup && children.value.set(id, [])\n\n        if (parentId != null) {\n          children.value.set(parentId, [...children.value.get(parentId) || [], id])\n        }\n      },\n      unregister: id => {\n        if (isUnmounted) return\n\n        children.value.delete(id)\n        const parent = parents.value.get(id)\n        if (parent) {\n          const list = children.value.get(parent) ?? []\n          children.value.set(parent, list.filter(child => child !== id))\n        }\n        parents.value.delete(id)\n        opened.value.delete(id)\n      },\n      open: (id, value, event) => {\n        vm.emit('click:open', { id, value, path: getPath(id), event })\n\n        const newOpened = openStrategy.value.open({\n          id,\n          value,\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n\n        newOpened && (opened.value = newOpened)\n      },\n      openOnSelect: (id, value, event) => {\n        const newOpened = openStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          opened: new Set(opened.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newOpened && (opened.value = newOpened)\n      },\n      select: (id, value, event) => {\n        vm.emit('click:select', { id, value, path: getPath(id), event })\n\n        const newSelected = selectStrategy.value.select({\n          id,\n          value,\n          selected: new Map(selected.value),\n          children: children.value,\n          parents: parents.value,\n          event,\n        })\n        newSelected && (selected.value = newSelected)\n\n        nested.root.openOnSelect(id, value, event)\n      },\n      children,\n      parents,\n    },\n  }\n\n  provide(VNestedSymbol, nested)\n\n  return nested.root\n}\n\nexport const useNestedItem = (id: Ref<unknown>, isGroup: boolean) => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  const uidSymbol = Symbol(getUid())\n  const computedId = computed(() => id.value ?? uidSymbol)\n\n  const item = {\n    ...parent,\n    id: computedId,\n    open: (open: boolean, e: Event) => parent.root.open(computedId.value, open, e),\n    openOnSelect: (open: boolean, e?: Event) => parent.root.openOnSelect(computedId.value, open, e),\n    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),\n    parent: computed(() => parent.root.parents.value.get(computedId.value)),\n    select: (selected: boolean, e?: Event) => parent.root.select(computedId.value, selected, e),\n    isSelected: computed(() => parent.root.selected.value.get(toRaw(computedId.value)) === 'on'),\n    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === 'indeterminate'),\n    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),\n    isGroupActivator: parent.isGroupActivator,\n  }\n\n  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup)\n\n  onBeforeUnmount(() => {\n    !parent.isGroupActivator && parent.root.unregister(computedId.value)\n  })\n\n  isGroup && provide(VNestedSymbol, item)\n\n  return item\n}\n\nexport const useNestedGroupActivator = () => {\n  const parent = inject(VNestedSymbol, emptyNested)\n\n  provide(VNestedSymbol, { ...parent, isGroupActivator: true })\n}\n"]},"metadata":{},"sourceType":"module"}